{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Warwick McNaughton's</p>"},{"location":"#helios-server-documentation","title":"Helios server documentation","text":"<p>For problems, suggestions and discussion:    https://github.com/wrmack/helios-server-docs/discussions</p> <p>For earlier documentation see:</p> <p>Helios Voting Installation Helios Voting Docs</p> <p>Community support: </p> <p>Helios Voting Google Group </p> <p>Motivation</p> <p>Helios is an important milestone in the development of secure online voting.  As someone who is involved in running elections at a local government level this is something I am keen to see being progressed. If people are going to run elections online it is important they use the most secure systems available. The motivation for creating this documentation is to make Helios more accessible for those wishing to deploy Helios.  It is based on my own exploration of Helios and does not purport to be official documentation.</p> <p>Source</p> <p>The documentation source code is on Github: https://github.com/wrmack/helios-server-docs</p> <p>Please leave any questions about this documentation or suggestions for improving this documentation under Discussions.  Also share your own experience with setting up an election.</p> <p>Please leave any comments about technical problems running this documentation under Issues.</p> <p>Warwick</p>"},{"location":"acknowledgements/","title":"Acknowledgements","text":""},{"location":"con_coercion/","title":"Coercion","text":"<p>A voter should not be intimidated (coerced) into voting the way the coercer wants.  Democracy depends on individuals being able to freely cast their votes without coercion, bribery or any form of improper influence.  A voter's vote should be secret to protect the voter from coercion:</p> <ul> <li>Ballot Secrecy: the voting system must not reveal who the voter voted for.</li> <li>Receipt-freeness: the voting system should not give the voter any evidence to prove to a third party how she voted.</li> <li>Coercion-Resistance: the voter should be able to cast a vote for her intended choice even while appearing to cooperate with a coercer.1</li> </ul> <ol> <li> <p>An Overview of End-to-End Verifiable Voting Systems Syed Taha Ali and Judy Murray. (2016) \u21a9</p> </li> </ol>"},{"location":"con_e2ev/","title":"End-to-end verifiability","text":"<p>Voters and candidates should not have to blindly trust that electronic election technology works.  It might be compromised by an attacker or it might be incorrectly coded.  How do voters and candidates know the result is correct?  End-to-end verifiability (E2E-V) provides for voters and candidates to verify an election result is correct.1 2 </p> <p>Verifiability is generally exhibited by:</p> <ul> <li>Individual Verifiability: a voter can verify that her vote is included in the set of all cast votes.</li> <li>Universal Verifiability: an observer can verify that the tally has been correctly computed from the set of all cast votes.</li> </ul> <p>Verifiability can be acheived as follows:</p> <ul> <li>Cast As Intended: voters make their selections and, at the time of vote casting, can get convincing evidence that their encrypted votes accurately reflect their choices;</li> <li>Recorded As Cast: voters or their designees can check that their encrypted votes have been correctly included, by finding exactly the encrypted value they cast on a public list of encrypted cast votes; and</li> <li>Tallied As Recorded: any member of the public can check that all the published encrypted votes are correctly included in the tally, without knowing how any individual voted.</li> </ul> <ol> <li> <p>End-to-end verifiability Josh Benaloh, Microsoft Research. Ronald Rivest, MIT.  Peter Y. A. Ryan University of Luxembourg.  Philip Stark, UC Berkeley.  Vanessa Teague, University of Melbourne.  Poorvi Vora, George Washington University. (2014) \u21a9</p> </li> <li> <p>An Overview of End-to-End Verifiable Voting Systems Syed Taha Ali and Judy Murray. (2016) \u21a9</p> </li> <li> <p>The Future of Voting: End-to-End Verifiable Internet Voting - Specification and Feasibility Study U.S. Vote Foundation (2015) \u21a9</p> </li> </ol>"},{"location":"con_helios/","title":"How Helios works.","text":"<p>(A general description is provided in Wikipedia.)</p> <p>Helios is a truly verifiable voting system, which means that:</p> <ul> <li>Alice can verify that her vote was correctly captured,</li> <li>all captured votes are displayed (in encrypted form) for all to see.</li> <li>anyone can verify that the captured votes were correctly tallied.1</li> </ul> <p>An election is created by naming a set of trustees and running a protocol that provides each of them with a share of the secret part of a public key pair. The public part of the key is published. Each of the eligible voters is also provided with a private pseudo-identity. The steps that participants take during a run of Helios are as follows.2</p> <ol> <li>To cast a vote, the user runs a browser script that inputs her vote and creates a ballot that is encrypted with the public key of the election. The ballot includes a ZKP (Zero Knowledge Proof) that the ballot represents an allowed vote (this is needed because the ballots are never decrypted individually).</li> <li>The user can audit the ballot to check if it really represents a vote for her chosen candidate; if she elects to do this, the script provides her with the random data used in the ballot creation. She can then independently verify that the ballot was correctly constructed, but the ballot is now invalid and she has to create another one.</li> <li>When the voter has decided to cast her ballot, the voter\u2019s browser submits it along with her pseudo-identity to the server. The server checks the ZKPs of the ballots, and publishes them on a bulletin board.</li> <li>Individual voters can check that their ballots appear on the bulletin board. Any observer can check that the ballots that appear on the bulletin board represent allowed votes, by checking the ZKPs.</li> <li>The server homomorphically combines the ballots, and publishes the encrypted tally. Anyone can check that this tally is done correctly.</li> <li>The server submits the encrypted tally to each of the trustees, and obtains their share of the decryption key for that particular ciphertext, together with a proof that the key share is well-formed. The server publishes these key shares along with the proofs. Anyone can check the proofs.</li> <li>The server decrypts the tally and publishes the result. Anyone can check this decryption.</li> </ol> <p>There is also a good explanation in Usability Analysis of Helios - An Open Source Verifiable Remote Electronic Voting System</p> <ol> <li> <p>Helios documentation \u21a9</p> </li> <li> <p>This description is taken from https://bensmyth.com/files/Smyth10-definition-verifiability.LNCS.pdf \u21a9</p> </li> </ol>"},{"location":"deploy_aws_walkthrough/","title":"AWS walk-through","text":"<p>Deploying Helios to AWS (Amazon Web Services)</p>"},{"location":"deploy_aws_walkthrough/#introduction","title":"Introduction","text":"<p>AWS provides a large range of services.  This deployment uses the following services:</p> <ul> <li>Elastic Compute, or EC2, which provides a virtual server instance</li> <li>Elastic Block Store, or EBS, which provides the 'hard drive' for the server instance</li> <li>Elastic IP Address, which provides a persistent IP address (the IP address associated with an EC2 instance may change if the instance is stopped and restarted)</li> <li>Route 53 for obtaining a domain name (required for setting up https)</li> <li>Simple Email Service, or SES, for sending emails </li> <li>Identity and Access Management, or IAM, for obtaining keys for programmatic access to the SES API</li> </ul> <p>All of these services are in the free tier except for a domain name which costs $12 USD per year for a .com name.  The free tier includes services which are always free and services which are only free for the first 12 months.  The most expensive service of the above is the EC2 instance which is free for 12 months.  Once outside the free tier's 12 month period if you are paying on demand you might consider stopping the instance when you are not using it (eg if you are only using it for development purposes).  Data persists provided the EBS remains attached.</p> <p>Other options might include:</p> <ul> <li>Lightsail, instead of EC2, which provides an easier setup process and has an option for Django frameworks</li> <li>Relational Database Service, or RDS, for providing a postgresql database (our deployment will simply install postgresql on the EC2 instance)</li> </ul> <p>This deployment assumes:</p> <ul> <li>you have created an account on AWS and are logged into the management console</li> <li>you have set up authentication for Google OAuth (to allow logging in to Helios)</li> </ul> <p>Caveat: this deployment has not been tested with a real election.  It may help to get you started.</p>"},{"location":"deploy_aws_walkthrough/#create-an-ec2-instance","title":"Create an EC2 instance","text":"<ul> <li>click on Services in the top menu bar and from the drop-down select EC2 under Compute</li> <li>click on the red button Launch instance</li> <li>select the free tier Amazon Linux 2 AMI (should be the very first one)</li> <li>for instance type, select the free tier t2.micro then click the button Configure Instance<ul> <li>if you are not eligible for the free tier for some reason, a relatively cheap alternative is a t4g.micro instance</li> <li>it is a bit cheaper than t2.micro</li> <li>its architecture is ARM64 </li> <li>after the free 12 months I moved to a t4g.micro instance and was able to install Helios</li> </ul> </li> <li>no changes, click button Add Storage; this is the EBS volume to be attached to your EC2 instance with a default size of 8 GB</li> <li>no changes, click button Add Tags; adding tags is optional</li> <li>click button Configure Security Group which configures which ports should be open</li> <li>add these rules to the default SSH one:<ul> <li>Postgresql (from drop-down) (port 5432, source 0.0.0.0/0)</li> <li>HTTP</li> <li>HTTPS</li> </ul> </li> <li>click button Review and Launch</li> <li>click button Launch which pops up a window for creating a key pair</li> <li>create a new key pair, give it a name and download the private key (.pem file), then click Launch</li> <li>click on View Instances to go to the EC2 Instances page</li> <li>click on the Instance ID to view detailed information about the instance</li> <li>get an Elastic IP which will persist: <ul> <li>in left side-bar click Elastic IPs</li> <li>click red button Allocate Elastic IP address</li> <li>click red button Allocate</li> <li>on Elastic IP addresses page select the Elastic IP address then in the Actions drop-down select Associate Elastic IP address</li> <li>in the Instance box select your instance then click the red button Associate</li> </ul> </li> <li>you now have remote SSH access to your instance using its Elastic IP address or Public IPv4 DNS</li> <li>EC2 users are all <code>ec2-user</code></li> </ul> <pre><code>ssh -i path_to_keypair.pem ec2-user@elastic_ip_address\n</code></pre> <ul> <li>the following shows the virtual disk space on your EBS volume:</li> </ul> <pre><code>sudo df -h /\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/xvda1      8.0G  1.4G  6.7G  18% /\n</code></pre>"},{"location":"deploy_aws_walkthrough/#install-helios","title":"Install Helios","text":"<p>Option: Clone from Github</p> <pre><code># ssh into your instance (if not already in it) \nssh -i path_to_keypair.pem ec2-user@elastic_ip_address\ngit clone https://github.com/benadida/helios-server.git\n</code></pre> <p>Option: Upload from a local directory  - use rsync to upload to your EC2 instance (substitute correct values for path_to_keypair.pem, path_to/helios-server-master, elastic_ip_address):</p> <pre><code>rsync -av -e \"ssh -i path_to_keypair.pem\" path_to/helios-server-master  ec2-user@elastic_ip_address:/home/ec2-user\n</code></pre>"},{"location":"deploy_aws_walkthrough/#install-python-postgresql-helios-requirements-rabbitmq","title":"Install python, postgresql, helios requirements, rabbitmq","text":"<ul> <li>do the following:</li> </ul> <pre><code># ssh into your instance (if not already in it) \nssh -i path_to_keypair.pem ec2-user@elastic_ip_address\n\n# python3\nsudo yum install python3 -y\n\n# postgresql\nsudo yum install postgresql-server -y\nsudo postgresql-setup initdb\nsudo systemctl enable postgresql.service\nsudo systemctl start postgresql.service\nsudo -i -u postgres psql postgres\nCREATE USER \"ec2-user\" WITH SUPERUSER;\nCREATE DATABASE helios WITH OWNER \"ec2-user\";\n\\q\nexit\n\n# rabbitmq - option 1 (if you have version incompatabilities try option 2)\ncurl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash\ncurl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash\nsudo yum install erlang -y\nsudo yum install rabbitmq-server -y\nsudo /sbin/service rabbitmq-server start\n\n# rabbitmq - option 2\n# I needed this option instead of option 2 in order to get compatible versions of erlang and rabbitmq-server \n# Following disables all repos except epel and disables the priorities plugin\nsudo yum --disablerepo='*' --enablerepo='epel' --disableplugin=priorities install erlang rabbitmq-server\nsudo /sbin/service rabbitmq-server start\n\n# install Helios dependencies and initialise database\nsudo yum install gcc -y               # Required to build psycopg2 from source\nsudo yum install python3-devel -y     # Required to build psycopg2 from source\nsudo yum install postgresql-devel -y  # Required to build psycopg2 from source\ncd ~/helios-server\npython3 -m venv venv\nsource venv/bin/activate\npython3 -m pip install wheel\n\nnano requirements.txt\n# Set version of django-ses==2.0.0 if version lower than this\n# Delete boto (django-ses v2.0.0 will result in boto3 being installed)\n# This implements AWS signature4 scheme. Otherwise sending emails will fail.\n\npython3 -m pip install -r requirements.txt\npython3 -m pip install django-environ  # So can use environ module\npython3 manage.py migrate              # Initialise the helios database\n\n# In settings.py\nALLOWED_HOSTS = ['your_elastic_ip','localhost']\nCELERY_BROKER_URL = get_from_env('CELERY_BROKER_URL', 'amqp://localhost')\n\n# start celery (still in venv environment)\ncelery -A helios worker -l INFO\n</code></pre>"},{"location":"deploy_aws_walkthrough/#nginx","title":"Nginx","text":"<ul> <li>if you wish to leave celery running then open another termimal and </li> </ul> <pre><code>ssh -i path_to_keypair.pem ec2-user@elastic_ip_address\n</code></pre> <ul> <li>install Nginx</li> </ul> <pre><code>sudo amazon-linux-extras install nginx1 -y\n</code></pre> <ul> <li>create /etc/systemd/system/gunicorn.socket</li> </ul> <pre><code>sudo nano /etc/systemd/system/gunicorn.socket\n</code></pre> <ul> <li>content of gunicorn.socket</li> </ul> <pre><code>[Unit]      \nDescription=gunicorn socket\n\n[Socket]      \nListenStream=/run/gunicorn.sock\n\n[Install]      \nWantedBy=sockets.target\n</code></pre> <ul> <li>create /etc/systemd/system/gunicorn.service</li> </ul> <pre><code>sudo nano /etc/systemd/system/gunicorn.service\n</code></pre> <ul> <li>content of gunicorn.service</li> </ul> <pre><code>[Unit]\nDescription=gunicorn daemon\nRequires=gunicorn.socket\nAfter=network.target\n\n[Service]\nUser=ec2-user\nGroup=ec2-user\nWorkingDirectory=/home/ec2-user/helios-server\nExecStart=/home/ec2-user/helios-server/venv/bin/gunicorn \\\n--access-logfile - \\\n--workers 3 \\\n--bind unix:/run/gunicorn.sock \\\nwsgi:application\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <ul> <li>open /etc/nginx/nginx.conf</li> </ul> <pre><code>sudo nano /etc/nginx/nginx.conf\n</code></pre> <ul> <li>content of nginx.conf </li> </ul> <pre><code>user nginx;\nworker_processes auto;\nerror_log /var/log/nginx/error.log;\npid /run/nginx.pid;\n\ninclude /usr/share/nginx/modules/*.conf;\n\nevents {\n    worker_connections 1024;\n}\n\nhttp {\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    access_log  /var/log/nginx/access.log  main;\n\n    sendfile            on;\n    tcp_nopush          on;\n    tcp_nodelay         on;\n    keepalive_timeout   65;\n    types_hash_max_size 4096;\n\n    include             /etc/nginx/mime.types;\n    default_type        application/octet-stream;\n\n    include            /etc/nginx/conf.d/*.conf;\n    include            /etc/nginx/sites-enabled/*;   # This might not be present by default\n\n    server {\n        listen         80;\n        listen         [::]:80;\n        server_name    _;\n        root           /usr/share/nginx/html;\n\n        # Load configuration files for the default server block.\n        include        /etc/nginx/default.d/*.conf;\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n    }\n}\n</code></pre> <ul> <li>create directory /etc/nginx/sites-available</li> </ul> <pre><code>sudo mkdir /etc/nginx/sites-available\n</code></pre> <ul> <li>create /etc/nginx/sites-available/helios</li> </ul> <pre><code>sudo nano /etc/nginx/sites-available/helios\n</code></pre> <ul> <li>content of helios (replace your_elastic_ip with your own)</li> </ul> <pre><code>server {\n    listen        80;\n    server_name   your_elastic_ip;\n\n    location =    /favicon.ico { access_log off; log_not_found off; }\n\n    location / {\n      proxy_pass http://unix:/run/gunicorn.sock;\n    }\n}\n</code></pre> <ul> <li>link sites-enabled to sites-available</li> </ul> <pre><code>sudo ln -s /etc/nginx/sites-available/helios /etc/nginx/sites-enabled/helios\n</code></pre>"},{"location":"deploy_aws_walkthrough/#check-if-site-loads-1","title":"Check if site loads - 1","text":"<ul> <li>start services</li> </ul> <pre><code># Enable services to run when system boots\nsudo systemctl enable gunicorn.socket  \nsudo systemctl enable gunicorn.service\nsudo systemctl enable nginx\n\n# Make system aware of changes\nsudo systemctl daemon-reload          \n\n# Start or restart services\nsudo systemctl start gunicorn.socket   \nsudo systemctl start gunicorn.service\nsudo systemctl start nginx\n</code></pre> <ul> <li>in your browser go to http://your_elastic_ip_address</li> <li>it will not be possible to log in because we have not yet set up Google authentication which requires SSL</li> <li>options for troubleshooting and viewing error messages:</li> </ul> <pre><code>sudo nginx -t  # Checks configuration of Nginx\nsudo systemctl status nginx.service\nsudo cat /var/log/nginx/error.log\nsudo cat /var/log/nginx/access.log\nsudo journalctl -xe\n</code></pre>"},{"location":"deploy_aws_walkthrough/#convert-site-to-https","title":"Convert site to https","text":"<ul> <li>we use certbot which blacklists AWS instance names (because they are ephemeral) so we need a permanent domain name</li> <li>there is a cost of $12 USD per year for a .com name</li> <li>obtain a domain name by going to the Route 53 service<ul> <li>click the Services drop-down on the AWS menubar </li> <li>select Route 53 under Networking and Content Delivery</li> <li>in the left side-bar select Registered domains then click the blue button Register Domain</li> <li>follow the prompts to purchase a domain name</li> <li>back on the Route 53 home page select Hosted zones in the left side-bar</li> <li>under Quick create record create a subdomain name (eg helios to give helios.your_domain.com)</li> <li>record type should be A and Value type should be your elastic ip</li> <li>click the red button Create records</li> <li>you have now associated your sub-domain with your elastic ip address</li> </ul> </li> <li>install certbot</li> <li>followed AWS doc</li> </ul> <pre><code>sudo yum install -y certbot python2-certbot-nginx\nsudo certbot\n</code></pre> <ul> <li>your `/etc/nginx/sites-available/helios should now look like:</li> </ul> <pre><code>server {\n  listen        80;\n  server_name   your_domain_name;\n  return        301 https://$host$request_uri;    # Causes http to redirect to https\n}\n\nserver {\n   listen       443 ssl http2;\n   listen       [::]:443 ssl http2;\n   server_name  your_domain_name;\n\n   ssl_certificate \"/etc/letsencrypt/live/your_domain_name/cert.pem\";\n   ssl_certificate_key \"/etc/letsencrypt/live/your_domain_name/privkey.pem\";\n   ssl_session_cache shared:SSL:1m;\n   ssl_session_timeout  10m;\n   ssl_ciphers HIGH:SEED:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!RSAPSK:!aDH:!aECDH:!EDH-DSS-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA:!SRP;\n   ssl_prefer_server_ciphers on;\n\n   # Load configuration files for the default server block.\n   include /etc/nginx/default.d/*.conf;\n\n   error_page 404 /404.html;\n       location = /40x.html {\n   }\n\n   error_page 500 502 503 504 /50x.html;\n       location = /50x.html {\n   }\n}\n</code></pre>"},{"location":"deploy_aws_walkthrough/#automatic-renewal-optional","title":"Automatic renewal - optional","text":"<ul> <li>to automatically renew the certificate when it expires</li> <li>edit <code>/etc/crontab</code> and add:</li> </ul> <pre><code>39      1,13    *       *       *       root    certbot renew --no-self-upgrade\n</code></pre> <ul> <li>that should automatically check for correct configuration, if it fails for any reason you may need to manually put the certificate and key in the correct directory</li> </ul>"},{"location":"deploy_aws_walkthrough/#google-authentication","title":"Google authentication","text":"<ul> <li>you should have a .env file in your helios root directory for keeping secret credentials:</li> </ul> <pre><code>GOOGLESECRET=xxxxxxxxxxxxxxxxxx\nGOOGLEID=xxxxxxxxxxxxxxxxxx\n</code></pre> <ul> <li>update settings.py - these seem to be the key changes to make:</li> </ul> <pre><code># Read in secrets from your .env file\nimport environ\nenv = environ.Env()\nenviron.Env.read_env()\nGOOGLESECRET = env('GOOGLESECRET')\nGOOGLEID = env('GOOGLEID')\n\nDEBUG = (get_from_env('DEBUG', '0') == '0')\n\nALLOWED_HOSTS = ['localhost',''your_elastic_ip','your_domain_name']\n\nURL_HOST = get_from_env(\"URL_HOST\", \"https://your_domain_name).rstrip(\"/\")\n\nGOOGLE_CLIENT_ID = get_from_env('GOOGLE_CLIENT_ID', GOOGLEID)\nGOOGLE_CLIENT_SECRET = get_from_env('GOOGLE_CLIENT_SECRET', GOOGLESECRET)\n\n</code></pre> <ul> <li>if you use Google for authentication you will need to add your new domain name to authorised urls in Google credentials</li> </ul>"},{"location":"deploy_aws_walkthrough/#check-if-site-loads-2","title":"Check if site loads - 2","text":"<ul> <li>start celery in venv environment if not already running</li> </ul> <pre><code>celery -A helios worker -l INFO\n</code></pre> <ul> <li>restart all services</li> </ul> <pre><code>sudo systemctl daemon-reload\nsudo systemctl restart gunicorn.socket\nsudo systemctl restart gunicorn.service\nsudo systemctl restart nginx\n</code></pre> <ul> <li>in your browser go to https://your_domain_name</li> <li>if that loads without error check that http redirects to https:  http://your_domain_name</li> <li>try logging on with Google</li> <li>if all this succeeds you should be able to set up an election but not be able to email voters yet</li> </ul>"},{"location":"deploy_aws_walkthrough/#set-up-email","title":"Set up email","text":"<ul> <li>AWS provides the AWS Simple Email Serivce (SES)</li> <li>there is a django backend (django-SES) that talks to this service</li> <li>to use this, it is necessary to have programmatic access to AWS SES APIs</li> <li>to create a user who has access, go to the AWS service IAM (in the drop-down list of services under Security, Identity &amp; Compliance) </li> <li>in the left side-bar select Users then click the blue button Add user</li> <li>provide a user name and select Programmatic access</li> <li>select Attach existing policies directly then search for SES and select AmazonSESFullAccess</li> <li>(optional) add a tag</li> <li>review and click blue button Create user</li> <li>important: record the Access key ID and Secret access key</li> <li>in your .env file add </li> </ul> <pre><code>AWS_SES_ACCESS_KEY_ID=your_access_key_id\nAWS_SES_SECRET_ACCESS_KEY=your_secret_access_key\n</code></pre> <ul> <li>in settings.py include the following entries:</li> </ul> <pre><code>AWS_SES_REGION_NAME = 'us-east-1'                              # change this if you use a different region\nAWS_SES_REGION_ENDPOINT = 'email.us-east-1.amazonaws.com'      # change this if you use a different region\nAWS_SES_ACCESS_KEY_ID = env('AWS_SES_ACCESS_KEY_ID')\nAWS_SES_SECRET_ACCESS_KEY = env('AWS_SES_SECRET_ACCESS_KEY')\n\nEMAIL_BACKEND = 'django_ses.SESBackend'\n</code></pre> <ul> <li>AWS SES initially places your SES account in a sandbox (it has restrictions) and requires email senders to be verified</li> <li>on the Amazon SES page, in the left side-bar, select Verified identities and add email addresses for verification</li> <li>the system sends an email to each address asking for verification by reply</li> <li>make sure DEFAULT_FROM_EMAIL in settings.py is a verified email address</li> <li>optionally, in your venv environment, test email works with:</li> </ul> <pre><code>python manage.py shell\n&gt;&gt;&gt; from django.core.mail import send_mail\n&gt;&gt;&gt; send_mail('Subject', 'Message', 'one_of_your_verified_email_addresses_as_sender', ['one_of_your_verified_email_addresses_as_receiver'])\n</code></pre>"},{"location":"deploy_aws_walkthrough/#check-if-site-loads-3","title":"Check if site loads - 3","text":"<ul> <li>start celery in venv environment if not already running</li> </ul> <pre><code>celery -A helios worker -l INFO\n</code></pre> <ul> <li>restart all services</li> </ul> <pre><code>sudo systemctl daemon-reload\nsudo systemctl restart gunicorn.socket\nsudo systemctl restart gunicorn.service\nsudo systemctl restart nginx\n</code></pre> <ul> <li>in your browser go to https://your_domain_name </li> </ul>"},{"location":"deploy_aws_walkthrough/#daemonise-celery-to-start-automatically","title":"Daemonise Celery to start automatically","text":"<ul> <li>create /etc/systemd/system/celery.service</li> </ul> <pre><code>sudo nano /etc/systemd/system/celery.service\n</code></pre> <ul> <li>content of celery.service:</li> </ul> <pre><code>[Unit]\nDescription=Celery Service\nAfter=network.target\n\n[Service]\nUser=ec2-user\nGroup=ec2-user\nWorkingDirectory=/home/ec2-user/helios-server\nExecStart=/home/ec2-user/helios-server/venv/bin/celery -A helios worker -l INFO\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <ul> <li>then</li> </ul> <pre><code>sudo systemctl daemon-reload          # Get systemd to recognise celery.service\nsudo systemctl enable celery.service  # Get celery.servce to run whenver rebooted\nsudo systemctl start celery.service   # Start Celery\n</code></pre>"},{"location":"deploy_aws_walkthrough/#troubleshooting","title":"Troubleshooting","text":""},{"location":"deploy_aws_walkthrough/#postgresql","title":"Postgresql","text":"<ul> <li>you may need to edit pg_hba.conf (located at /var/lib/pgsql/data/pg_hba.conf) </li> <li>for lines commencing <code>host</code> change the METHOD from <code>ident</code> to <code>md5</code></li> </ul>"},{"location":"deploy_heroku_walkthrough/","title":"Heroku walk-through","text":"<p>Deploying Helios to Heroku.</p>"},{"location":"deploy_heroku_walkthrough/#caveats","title":"Caveats","text":"<p>I put this walk-through together when Heroku had a free tier. From November 2022 Heroku no longer has a free tier and I have removed my apps.  Therefore I have not tested this deployment recently under the new arrangements.  </p> <p>Also, it has not been tested with a real election.  </p> <p>However the walk-through might help to get you started.</p>"},{"location":"deploy_heroku_walkthrough/#about-heroku","title":"About Heroku","text":"<p>Heroku is a subsidiary of salesforce.com. Its servers are hosted on Amazon's EC2 cloud-computing platform.</p> <p>When an app is deployed it runs in a container called a \u2018dyno\u2019.  There is no direct access to its filesystem.  There is more about dynos here.</p> <p>Deployment</p> <p>There are options for deploying an app.  One option is to link to a Github repository so that a push to Github triggers a build and deployment.</p> <p>Configuration</p> <p>There is one required configuration file - Procfile.  This tells Heroku what to run when an app is deployed.  I use the following for running one web server process and one Celery worker process:</p> <pre><code>web: gunicorn wsgi\nworker: celery worker -A helios -l info\n</code></pre> <p>Building and debugging</p> <p>Build logs can be viewed through Heroku\u2019s web interface, but for anything more than that it is important to become familiar with the Heroku CLI application.  Heroku CLI can also run a psql shell for examining the database. Run this for a real-time display of logs generated on the Heroku site (if helios-heroku is the name of your app on Heroku):</p> <pre><code>heroku logs --tail -a helios-heroku\n</code></pre> <p>Helios requirements</p> <p>For tasks, Celery may be used and there are options for a broker (for example Redis).</p> <p>For sending email, an add-on, SendGrid, can be used. This is free up to 12,000 emails per month. </p>"},{"location":"deploy_heroku_walkthrough/#assumptions","title":"Assumptions","text":"<ul> <li>helios server is installed locally</li> <li>helios server is managed through git</li> <li>helios server has a remote repository on Github</li> <li>you have created an account on Heroku and are logged in</li> <li>you have downloaded and installed Heroku CLI which we will use for accessing the database.</li> </ul>"},{"location":"deploy_heroku_walkthrough/#create-a-web-app-to-run-the-helios-server-on-heroku-by-using-heroku-dashboard","title":"Create a web app to run the Helios server on Heroku by using Heroku dashboard","text":"<ul> <li>go to https://dashboard.heroku.com</li> <li>go to New - Create new app</li> <li>give it a name and click Create app</li> <li>you should now be in the \"Deploy\" tab</li> <li>for \"Deployment method\" select Github</li> <li>for \"Connect to Github\" enter your repository name eg helios-server</li> <li>when Heroku has found your Github repository it will list it with a Connect button alongside</li> <li>click Connect</li> <li>your app name is referred to below as APPNAME - substitute the actual name you gave it</li> </ul>"},{"location":"deploy_heroku_walkthrough/#preparing-helios-server-for-deployment-to-heroku","title":"Preparing helios server for deployment to Heroku","text":"<ul> <li>Heroku requires a Procfile - create a file <code>Procfile</code> with the following content</li> </ul> <pre><code>web: gunicorn wsgi:application -b 0.0.0.0:$PORT -w 8\nworker: celery worker --app helios --events --beat --concurrency 1\n</code></pre> <ul> <li>you may go to \"Deploy by using the Heroku dashboard\" below at any time to examine error messages and comfirm whether you need to do the following.</li> </ul> <p>Secret environment variables (such as passwords)</p> <ul> <li>secrets need to be passed to Heroku as environment variables when you set up your Heroku app (so they are not visible in any files you have on Github)</li> <li>if you added a <code>.env</code> file and imported <code>environ</code> into <code>settings.py</code> for local development, remove them for deployment to Heroku</li> <li>go to the Settings tab on Heroku's dashboard page for your app and select Reveal Config Vars</li> <li>add your authentication credentials, eg in <code>settings.py</code> you might have:</li> </ul> <pre><code>          GOOGLE_CLIENT_ID = os.environ['GOOGLEID']\n          GOOGLE_CLIENT_SECRET = os.environ['GOOGLESECRET']       \n</code></pre> <p>in which case you would add the keys GOOGLEID and GOOGLESECRET as 'config vars' and enter the appropriate values for each.</p> <ul> <li>make sure that in Google console you enter the correct uris: </li> </ul> <pre><code>    # Authorised JavaScript origins\n\n    https://APPNAME.herokuapp.com\n\n    #Authorised redirect URIs\n\n    https://APPNAME.herokuapp.com/auth/after/\n\n</code></pre> <p>Settings</p> <ul> <li>other changes in <code>settings.py</code>:<ul> <li>add the Heroku host to the ALLOWED_HOSTS array <code>shell ALLOWED_HOSTS = ['APPNAME.herokuapp.com']</code></li> <li>for URL_HOST add the Heroku url (it will automatically be used for the SECURE_URL_HOST) <code>shell URL_HOST = get_from_env(\"URL_HOST\", \"https://APPNAME.herokuapp.com\").rstrip(\"/\")</code></li> <li>database settings should be:</li> </ul> </li> </ul> <pre><code>    DATABASES = {\n      'default': {\n          'ENGINE': 'django.db.backends.postgresql_psycopg2',\n          'NAME': 'helios',\n          'CONN_MAX_AGE': 600,\n      },\n    }\n\n    # override if we have an env variable\n    if get_from_env('DATABASE_URL', None):\n      import dj_database_url\n      DATABASES['default'] = dj_database_url.config(conn_max_age=600, ssl_require=True)\n      DATABASES['default']['ENGINE'] = 'django.db.backends.postgresql_psycopg2'\n</code></pre> <p>Celery</p> <ul> <li>Celery requires a process worker - we will use CloudAMQP which is available as a Heroku add-on</li> <li>on the Heroku dashboard page for your app go to the Resources tab and select Find more add-ons</li> <li>under Add-on categories go to Messaging and Queuing</li> <li>select CloudAMQP</li> <li>under Plans &amp; Pricing select Little Lemur (the free option) and Install CloudAMQP</li> <li>to provision the add-on for your app enter the name of your app and click Submit Order Form</li> <li>check it has been added by going to the Settings page  - Config Vars should now include a key CLOUDAMQP_URL</li> <li>on the Resources page switch on celery worker if it is not already</li> <li>in <code>settings.py</code> add:</li> </ul> <pre><code>CELERY_BROKER_URL = os.environ['CLOUDAMQP_URL']\nBROKER_URL = os.environ['CLOUDAMQP_URL']\n</code></pre> <p>Dependencies</p> <ul> <li>Heroku loads all dependencies that are in <code>requirements.txt</code></li> <li>if, in your local version of Helios, you loaded any dependency separately to what is in <code>requirements.txt</code> Heroku will not know about it, so put it in <code>requirements.txt</code>.</li> </ul> <p>Collectstatic</p> <ul> <li>by default, Heroku runs <code>python manage.py collectstatic</code> which we don't need so disable it:</li> </ul> <pre><code>heroku config:set DISABLE_COLLECTSTATIC=1 --app APPNAME\n</code></pre>"},{"location":"deploy_heroku_walkthrough/#deploy-by-using-the-heroku-dashboard","title":"Deploy by using the Heroku dashboard","text":"<ul> <li>commit all your changes and push to Github</li> <li>in Heroku dashboard for your app, in the Deploy tab, if you haven't set Enable Automatic Deploys, next to Manual deploy select the branch you want to deploy and click Deploy branch</li> <li>Heroku will attempt to install your helios server web app and it displays a log as it does this</li> <li>if it installs successfully Heroku will launch it</li> <li>click Open app at the top of the page to view your web page</li> <li>if launching fails, examine logs in a terminal with</li> </ul> <pre><code>heroku logs --tail --app APPNAME\n</code></pre> <ul> <li>there will be an error message because we have not set up the Postgreslq database yet.</li> </ul> <p>Database</p> <ul> <li>Heroku should have attached a Postgresql database to your app and created the 'helios' database in line with your database settings in <code>settings.py</code></li> <li>create a Heroku shell and populate the 'helios' database</li> </ul> <pre><code>heroku run bash --app APPNAME\n~ $ python manage.py makemigrations\n~ $ python manage.py migrate\n~ $ exit\n</code></pre> <ul> <li>check database tables have been created:</li> </ul> <pre><code>heroku pg:psql --app APPNAME\nAPPNAME::DATABASE=&gt; \\d\nAPPNAME::DATABASE=&gt; \\q\n</code></pre> <ul> <li>(optional) open your app again, or refresh it if it is already open in your browser - it should run this time, but you should be able to create an election but cannot yet send emails.</li> </ul>"},{"location":"deploy_heroku_walkthrough/#email","title":"Email","text":"<ul> <li>we need to set up an add-on that will take care of sending emails to voters - Heroku has a couple of third party add-ons that do this</li> <li>on the Heroku dashboard page for your app go to the Resources tab and select Find more add-ons</li> <li>under Add-on categories go to Email/SMS</li> <li>select Mailgun (or Sendgrid, Trustifi, CloudMailin)</li> <li>under Plans &amp; Pricing select Starter (the free option) and Install Mailgun</li> <li>to provision the add-on for your app enter the name of your app and click Submit Order Form</li> <li>check it has been added by going to the Settings page  - Config Vars should now include a number of keys relating to Mailgun</li> <li>your email settings in settings.py should be:</li> </ul> <pre><code>EMAIL_HOST = os.environ['MAILGUN_SMTP_SERVER']\nEMAIL_HOST_USER = os.environ['MAILGUN_SMTP_LOGIN']\nEMAIL_HOST_PASSWORD = os.environ['MAILGUN_SMTP_PASSWORD']\nEMAIL_PORT = 587\nEMAIL_USE_TLS = True\n</code></pre> <ul> <li>Mailgun places starting users in sandbox accounts which require email recipients to verify their email addresses (you can send an email to yourself without verification)</li> <li>to add recipients, on the Heroku dashboard page for your app go to the Resources tab and click on the Mailgun add-on which will take you to your account on Mailgun</li> <li>on the Mailgun dashbord, select the sandbox account</li> <li>on the right there is a side-box where it is possible to add recipients</li> <li>after a recipient is added, a confirmation email is automatically sent to the recipient who has to click an \"I agree\" button</li> <li>following the changes to settings.py, commit and push to Github</li> <li>go to the Heroku dashboard and, under Deploy, do a manual deploy if you have not set it up for automatic deploy</li> <li>you should now be able to send emails to yourself and verified recipients from within Helios</li> </ul>"},{"location":"faq_faq1/","title":"Faq faq1","text":"<p>[To be completed]</p>"},{"location":"faq_faq1/#for-voters","title":"For voters","text":"How does online voting with Helios Voting work? <p>This is the explanation</p> Do I need special internet skills or software to vote with Helios Voting? <p>No.  Voting takes place using your web browser.  Helios has been tested with Safari, Chrome, Firefox, (Edge?, Internet Explorer?, Opera?).   </p> <p>It should also work using the browser on your smart phone.  </p> <p>It is always best to have your browser updated to the most recent version.</p> How can I be assured my vote is counted? <p>Explanation</p>"},{"location":"faq_faq1/#for-election-admins","title":"For election admins","text":""},{"location":"faq_faq1/#about-security","title":"About security","text":""},{"location":"how_overview/","title":"Overview","text":"<p>This section on \"How it works\" is based on Ben Adida's documentation, my own experience with trying it out and my reading of the academic literature.  My aim is for it to be helpful for the general user (as opposed to a cryptographic expert who should consult the academic literature instead). Nevertheless, the cryptographic aspects are key security features and I will do my best to explain their implementation in lay-person terms.</p> <p>The following is a very brief summary of the key screens:</p> <ul> <li>pre-voting phase: the election setup</li> <li>voting phase: the voting booth</li> <li>post-voting phase: election results.</li> </ul>"},{"location":"how_overview/#pre-voting-phase-the-election-setup","title":"Pre-voting phase: the election setup","text":"<p>The election administrator: </p> <ul> <li>visits the election site (eg https://vote.heliosvoting.org) </li> <li>logs in</li> <li>sets up the election.</li> </ul> <p>If the administrator sets up the election for only those voters whose names are uploaded, the server sends an email to each voter. The email contains the election url, fingerprint and the log-in id and password of the voter.</p>"},{"location":"how_overview/#what-the-administrator-sees","title":"What the administrator sees","text":""},{"location":"how_overview/#what-the-administrator-sees-after-logging-in","title":"What the administrator sees after logging in","text":""},{"location":"how_overview/#voting-phase-the-voting-booth","title":"Voting phase: the voting booth","text":"<p>The voter:</p> <ul> <li>visits the link in the emaiil</li> <li>is presented with the voting booth</li> <li>selects their choices</li> <li>submits their ballot to the server.</li> </ul> <p>The email the voter receives contains:</p> <pre><code>Election URL: https://helios.wrmack.com/helios/e/Election_three/vote\nElection Fingerprint: stRyU7w/Ephk/ioLSXAGk5lHIwd+7KJ8lZa3lO2fD1I\n\nYour voter ID: ********\nYour password: ********\n</code></pre>"},{"location":"how_overview/#what-the-voter-sees-after-clicking-the-election-url","title":"What the voter sees after clicking the election url","text":""},{"location":"how_overview/#post-voting-phase-the-election-results","title":"Post-voting phase: the election results","text":"<p>Once voting is over, the election administrator causes the votes to be tallied.  The election administrator can send an email to each voter giving them a link to this screen:</p> <p></p>"},{"location":"how_security/","title":"Security features","text":"<p>Helios has been the subject of many academic papers written about the security of online voting systems.  You can find some of these papers in References - Academic papers.</p>"},{"location":"how_simple/","title":"Simple encryption model","text":"<p>A simple encryption model for conducting an election might go something like this:</p> <ul> <li>Election administrator sets up the election and creates a public - private key pair.</li> <li>Election administrator publishes the public key.</li> <li>Each voter encrypts their vote with the election public key and sends the encrypted vote to the election administrator.</li> <li>When the election closes, the administrator decrypts all votes using the private key and tallies the votes.</li> <li>The election administrator publishes the result.</li> </ul> <p>Communication of the vote would likely be over TLS and so it would be encrypted in transmission anyway.  The only security added by this model is that when it is received and stored on the server it is encrypted. The model has other problems.</p>"},{"location":"how_simple/#problems","title":"Problems","text":"<ul> <li>the election administrator is able to decrypt votes and may be able to determine how a particular voter voted (ballot privacy breached)</li> <li>the voter does not know whether their vote was correctly encrypted (cast-as-intended cannot be checked)</li> <li>the voter is not able to verify that the election outcome correctly represents their own vote (recorded-as-cast and tallied-as-recorded cannot be checked)</li> </ul>"},{"location":"inst_auth/","title":"Authentication systems","text":""},{"location":"inst_auth/#google","title":"Google","text":"<p>To get Google Auth working:</p> <p>** go to https://console.developers.google.com</p> <p>** create an application</p> <p>** set up oauth2 credentials as a web application, with your origin, e.g. https://myhelios.example.com, and your auth callback, which, based on our example, is https://myhelios.example.com/auth/after/</p> <p>** still in the developer console, enable the Google+ API.</p> <p>** set the GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET configuration variables accordingly.</p>"},{"location":"inst_dev/","title":"Local development","text":""},{"location":"inst_dev/#flow-for-starting-helios","title":"Flow for starting helios","text":""},{"location":"inst_dev/#start-rabbitmq","title":"Start rabbitmq","text":"<p>In a new terminal:</p> <pre><code>/usr/local/sbin/rabbitmq-server\n</code></pre>"},{"location":"inst_dev/#start-celery","title":"Start celery","text":"<p>In a new terminal, in helios-server root folder:</p> <pre><code>source venv/bin/activate\ncelery -A helios worker -l info\n</code></pre>"},{"location":"inst_dev/#start-helios","title":"Start helios","text":"<p>(In settings.py PRODUCTION = False to tell Django to use the development server)</p> <p>In a new terminal:</p> <pre><code>source venv/bin/activate\npython manage.py runserver\n</code></pre>"},{"location":"inst_dev/#view-in-browser","title":"View in browser","text":"<p>In browser go to: <code>http://localhost:8000</code></p>"},{"location":"inst_dev/#visual-studio-code","title":"Visual Studio Code","text":"<p>If using Visual Studio Code, to launch helios using the debugger add this to \"configurations\" in launch.json:</p> <pre><code>\n    {\n        \"name\": \"Python: Django\",\n        \"type\": \"python\",\n        \"request\": \"launch\",\n        \"program\": \"${workspaceFolder}/manage.py\",\n        \"args\": [\n            \"runserver\",\n            \"--noreload\"\n        ],\n        \"django\": true,\n        \"justMyCode\": false\n    }\n\n</code></pre> <p>Set \"justMyCode\" to True for Call Stack to show your own code only.</p>"},{"location":"inst_django/","title":"Django installation","text":""},{"location":"inst_django/#settingspy","title":"settings.py","text":"<p>Customise the following in settings.py:</p> <pre><code>ADMINS\nHOSTS\nDATABASES\nTIME, LANGUAGE\nHELP_EMAIL_ADDRESS\nAuthentication systems\nGOOGLE_CLIENT_ID\nGOOGLE_CLIENT_SECRET\nEmail settings\n</code></pre>"},{"location":"inst_django/#collectstatic","title":"collectstatic","text":"<p>What it does:</p> <ul> <li>collects all static files that are located in the static folders of the installed apps and stores them in the folder that is set as <code>STATIC_ROOT</code> (currently the /static folder).</li> </ul> <p>When to use:</p> <ul> <li>the <code>STATIC_ROOT</code> folder is empty </li> <li>or you have changed the static files in one of the installed app's static folders</li> </ul> <p>How to use:</p> <ul> <li>to completely refresh the files held in <code>STATIC_ROOT</code>, empty it first</li> <li>in terminal: </li> </ul> <pre><code>python manage.py collectstatic\n</code></pre>"},{"location":"inst_django/#makemigrations","title":"makemigrations","text":"<p>What it does:</p> <ul> <li>Migrations are Django\u2019s way of propagating changes you make to your models (adding a field, deleting a model, etc.) into your database schema. <code>makemigrations</code> creates new migrations based on the changes you have made to your models.</li> </ul> <p>When to use:</p> <ul> <li>After you make a change to your models.</li> </ul> <p>How to use:</p> <ul> <li>in a terminal: </li> </ul> <pre><code>python manage.py makemigrations\n</code></pre>"},{"location":"inst_django/#reset-database","title":"reset database","text":"<p>What it does:</p> <ul> <li>deletes your helios database, creates a new helios database and migrates your models to the database.</li> </ul> <p>When to use:</p> <ul> <li>After you have run <code>makemigrations</code></li> </ul> <p>How to use:</p> <pre><code>./reset.sh\n</code></pre>"},{"location":"inst_env/","title":"Environment essentials for local development","text":"<p>If not already installed:</p> <ul> <li> <p>install Python 3</p> </li> <li> <p>install PostgreSQL</p> </li> <li> <p>install Celery to run asynchronous tasks </p> </li> <li> <p>install RabbitMQ as the message broker recommended by Celery</p> </li> <li> <p>install pip, the python package manager</p> </li> </ul> <p>then:</p> <ul> <li> <p>download helios-server </p> </li> <li> <p>cd into the helios-server directory</p> </li> <li> <p>create a virtual environment:</p> </li> </ul> <pre><code>python3 -m venv venv  \n</code></pre> <ul> <li>activate the virtual environment:</li> </ul> <pre><code>source venv/bin/activate\n</code></pre> <ul> <li>install dependency requirements:</li> </ul> <pre><code>python3 -m pip install -r requirements.txt\n</code></pre>"},{"location":"inst_virtualbox/","title":"Walk-through of installing Ben Adida's Helios Election System on Ubuntu 20.10","text":"<ul> <li>(optional) install VSCode or VSCodium for editing code, having an integrated terminal</li> <li>check python3 is installed with Ubuntu and, if not, install it<ul> <li><code>python3 --version</code></li> </ul> </li> <li>install pip3<ul> <li><code>sudo apt install python3-pip</code></li> </ul> </li> <li>install python3-venv <code>sudo apt install python3-venv</code></li> <li>install Postgresql<ul> <li><code>sudo apt-get update</code></li> <li><code>sudo apt install postgresql</code></li> <li><code>sudo systemctl start postgresql@12-main</code> (prompted by the installation) </li> <li><code>sudo -i -u postgres</code> (become the postgres user)</li> <li><code>psql postgres</code> (connect to the postgres database)</li> <li><code>CREATE USER [your login name] WITH SUPERUSER;</code> (create Helios database user)</li> <li><code>CREATE DATABASE helios WITH OWNER [your login name];</code>  (create Helios database)</li> <li><code>\\q</code> (quit psql)</li> <li><code>exit</code> (logout as the postgres user)</li> <li><code>psql helios</code> (connect to the new helios database)</li> <li><code>\\l</code> (list databases - check helios is there)</li> <li><code>\\q</code></li> </ul> </li> <li>install RabbitMQ<ul> <li><code>sudo apt install rabbitmq-server</code></li> </ul> </li> <li> <p>setup Google OAuth authentication</p> <ul> <li>in a browser go to: https://console.developers.google.com/apis  (you should have a Google account)</li> <li>select <code>Credentials</code></li> <li><code>Create a project</code> and give it a name (eg Helios) then <code>CREATE CREDENTIALS</code></li> <li><code>OAuth client ID</code></li> <li><code>CONFIGURE CONSENT SCREEN</code> - select <code>External</code> then <code>CREATE</code></li> <li>Just complete the required fields (App name, User support email and Developer contact email) then <code>SAVE AND CONTINUE</code></li> <li>Under <code>Scopes</code> and <code>Optional info</code> add nothing just <code>SAVE AND CONTINUE</code> then on Summary page <code>BACK TO DASHBOARD</code></li> <li>select <code>Credentials</code> then <code>CREATE CREDENTIALS</code></li> <li>Application type is <code>Web application</code></li> <li>Name is your choice (eg Helios)</li> <li>Authorised Javascript origins: <code>http://localhost:8000</code></li> <li>Authorised redirect URIs: <code>http://localhost:8000/auth/after/</code></li> <li><code>CREATE</code></li> <li>copy <code>Client ID</code> and <code>Client secret</code> for using in Helios</li> <li>Select <code>Dashboard</code> then <code>ENABLE APIS AND SERVICES</code></li> <li>Select <code>Google People API</code> and <code>ENABLE</code></li> </ul> </li> <li> <p>download Helios code: in a browser </p> <ul> <li>go to https://github.com/benadida/helios-server</li> <li>under <code>Code</code> choose <code>Download ZIP</code></li> <li>once downloaded double-click the Zip arhive to unarchive it and move all to a project folder of your choice for working on (ie move code out of the Downloads folder)</li> </ul> </li> <li>prepare helios<ul> <li>cd to your project folder</li> <li>create a virtual environment <code>python3 -m venv my-venv</code></li> <li>activate the virtual environment: <code>source my-venv/bin/activate</code></li> <li>install all dependencies in requirements.txt: <ul> <li><code>python3 -m pip install wheel</code>  (in response to an error message)</li> <li><code>sudo apt install libpq-dev</code> (required for installation of psycopg2)</li> <li>(in <code>requirements.txt</code> I upgraded celery to 5.0.0 and replaced pycrypto with pycryptodome for compatability with python 3.8)</li> <li><code>python3 -m pip install -r requirements.txt</code></li> </ul> </li> </ul> </li> <li>safe storage of secrets <ul> <li>optional but if your code is kept on Github this is preferable to hard-coding your Google credentials into settings.py</li> <li><code>python3 -m pip install django-environ</code> </li> <li>create an <code>.env</code> file with stored secrets     <code>shell         DBPWD=xxxx         GOOGLESECRET=xxxx         GOOGLEID=xxxx</code></li> <li>in <code>settings.py</code> insert following after <code>import os</code>     ```shell         import environ<pre><code># Read in secrets from .env file\nenv = environ.Env()\nenviron.Env.read_env()  \nDBPWD = env('DBPWD')\nGOOGLESECRET = env('GOOGLESECRET')\nGOOGLEID = env('GOOGLEID')\n</code></pre> <p><code>- in `settings.py`:</code>shell     # google     GOOGLE_CLIENT_ID = get_from_env('GOOGLE_CLIENT_ID', GOOGLEID)     GOOGLE_CLIENT_SECRET = get_from_env('GOOGLE_CLIENT_SECRET', GOOGLESECRET) <code>``     - add</code>.env<code>to</code>.gitignore<code>so it is not uploaded to Github - in a separate terminal start celery     - cd to your helios project     -</code>source my-venv/bin/activate<code>-</code>celery -A helios worker -l INFO<code>- back at first terminal, run helios     -</code>python3 manage.py makemigrations<code>-</code>./reset.sh<code>-</code>python3 manage.py runserver<code>- in a browser go to</code>localhost:8000<code>(alternatively go to</code>127.0.0.1:8000` but change references to localhost in settings.py to 127.0.0.1 and in Google OAuth authentication replace localhost with 127.0.0.1)</p> </li> </ul> </li> </ul>"},{"location":"privacy/","title":"Privacy","text":"<p>I use Umami, an open source application, to count visits to pages.  This records which pages were viewed, a user's country, referrers, the operating systems and browsers of users.  It does not record any personal information.  It does not use this information for any other purpose than providing a dashboard displaying these statistics.</p>"},{"location":"ref_components/","title":"Components","text":""},{"location":"ref_components/#django-installed-apps","title":"Django installed apps","text":"<p>HelioSolid is an application which has been deployed to a server.  The application uses the Django web framework for serving pages and storing data.  The Django application comprises three \"installed apps\":</p> <ul> <li>server_ui</li> <li>helios_auth</li> <li>helios</li> </ul>"},{"location":"ref_components/#server_ui","title":"server_ui","text":"<p>The server_ui app presents the initial page with:</p>"},{"location":"ref_components/#helios","title":"helios","text":"<p>The helios app presents all pages relating to an election. It holds the list of registered voters for an election. It stores all encrypted ballots once they have been retrieved from voter's pods. It tallys the vote once all ballots have been retrieved. </p>"},{"location":"ref_components/#helios_auth","title":"helios_auth","text":"<p>The helios_auth app handles authentication. </p>"},{"location":"ref_components/#voting-booth","title":"Voting booth","text":"<p>Once an admin has uploaded a csv file of voters the admin will cause an email to be sent to voters which contains their login name and password and an url to the election.  When a voter clicks on the url the server presents the voter with the voting booth which is updated by javascript as the voter works through their voting selections.  The vote is encrypted in the browser.  There are no further network requests to the server until the voter decides to cast their vote.  The voting booth is decoupled from the server.</p>"},{"location":"ref_literature/","title":"Academic papers assessing Helios","text":""},{"location":"ref_literature/#2008","title":"2008","text":"<p>Helios: Web-based Open-Audit Voting Ben Adida Presentation of an early version of helios to the 17th USENIX Security Symposium, 2008</p>"},{"location":"ref_literature/#2009","title":"2009","text":"<p>Electing a University President using Open-Audit Voting: Analysis of real-world use of Helios  Ben Adida, Olivier Pereira, Olivier de Marneffe, Jean-Jacques Quisquater Presentation to Electronic Voting Technology Workshop/Workshop on Trustworthy Elections, 2009 </p> <p>Usability Study of the Open Audit Voting System Helios  Janna-Lynn Weber, Urs Hengartner</p>"},{"location":"ref_literature/#2010","title":"2010","text":"<p>Exploiting the Client Vulnerabilities in Internet E-voting Systems: Hacking Helios 2.0 as an Example  Saghar Estehghari, Yvo Desmedt</p> <p>The Helios e-Voting Demo for the IACR  Stuart Haber, Josh Benaloh, Shai Halevi</p>"},{"location":"ref_literature/#2011","title":"2011","text":"<p>Running mixnet-based elections with Helios Philippe Bulens, Damien Giry, Olivier Pereira Presentation to Electronic Voting Technology Workshop/Workshop on Trustworthy Elections, 2011</p> <p>User study of the improved Helios voting system interfaces Fatih Karayumak, Michaela Kauer, M. Maina Olembo, Tobias Volk, Melanie Volkamer</p> <p>Adapting Helios for provable ballot privacy  David Bernhard, V\u00e9ronique Cortier, Olivier Pereira, Ben Smyth, Bogdan Warinschi</p> <p>Usability Analysis of Helios - An Open Source Verifiable Remote Electronic Voting System Fatih Karayumak, Maina M. Olembo, Michaela Kauer and Melanie Volkamer</p>"},{"location":"ref_literature/#2013","title":"2013","text":"<p>A generic construction for voting correctness at minimum cost - Application to Helios V\u00e9ronique Cortier, David Galindo, St\u00e9phane Glondu, Malika Izabach\u00e8ne  </p> <p>Attacking and fixing Helios: An analysis of ballot secrecy V\u00e9ronique Cortier and Ben Smyth  </p> <p>Distributed ElGamal \u00e0 la Pedersen - Application to Helios  V\u00e9ronique Cortier, David Galindo, St\u00e9phane Glondu, Malika Izabache\u0300ne</p>"},{"location":"ref_literature/#2014","title":"2014","text":"<p>Usability of Voter Verifiable, End-to-end Voting Systems: Baseline Data for Helios, Pre\u0302t a\u0300 Voter, and Scantegrity II  Claudia Z. Acemyan, Philip Kortum, Michael D. Byrne, Dan S. Wallach</p> <p>Helios Verification: To Alleviate, or to Nominate: Is That The Question, Or Shall We Have Both?  Stephan Neumann, M. Maina Olembo, Karen Renaud, and Melanie Volkamer</p> <p>A Security Analysis of the Helios Voting Protocol and Application to the Norwegian County Election  Kristine Salamonsen (Masters thesis)</p>"},{"location":"ref_literature/#2015","title":"2015","text":"<p>Extending Helios Towards Private Eligibility Verifiability Oksana Kulyk, Vanessa Teague, and Melanie Volkamer E-Voting and Identity: 5th International Conference, VoteID 2015</p> <p>Election Verifiability for Helios under Weaker Trust Assumptions  Ve\u0301ronique Cortier, David Galindo, Ste\u0301phane Glondu and Malika Izabache\u0300ne</p>"},{"location":"ref_literature/#2016","title":"2016","text":"<p>Internet voting with Helios Olivier Pereira Chapter in: Feng Hao and Peter Y. A. Ryan (Eds.), Real-World Electronic Voting: Design, Analysis and Deployment, 2016</p> <p>The Cloudier Side of Cryptographic End-to-end Verifiable Voting: A Security Analysis of Helios Nicholas Chang-Fong, Aleksander Essex Proceedings of the 32nd Annual Conference on Computer Security Applications, 2016</p> <p>Implementation-level Analysis of the JavaScript Helios Voting Client Michael Backes, Christian Hammer, David Pfaff, Malte Skoruppa Proceedings of the 31st Annual ACM Symposium on Applied Computing, 2016</p> <p>How not to Prove Yourself: Pitfalls of the Fiat-Shamir Heuristic and Applications to Helios David Bernhard, Olivier Pereira, and Bogdan Warinschi  </p> <p>Adapting Helios for provable ballot privacy David Bernhard, V\u00e9ronique Cortier, Olivier Pereira, Ben Smyth, Bogdan Warinschi  </p> <p>Introducing Proxy Voting to Helios  Oksana Kulyk, Karola Marky, Stephan Neumann, Melanie Volkamer</p> <p>Apollo \u2013 End-to-end Verifiable Internet Voting with Recovery from Vote Manipulation  Dawid Gawel, Maciej Kosarzecki, Poorvi L. Vora, Hua Wu, and Filip Zag\u00f3rski</p> <p>Cryptographic Voting \u2014 A Gentle Introduction  David Bernhard, Bogdan Warinschi</p>"},{"location":"ref_literature/#2017","title":"2017","text":"<p>Machine-Checked Proofs of Privacy for Electronic Voting Protocols  V\u00e9ronique Cortier, Constantin C\u0103t\u0103lin Dr\u0103gan, Fran\u00e7ois Dupressoir, Benedikt Schmidt, Pierre-Yves Strub, Bogdan Warinschi</p> <p>Security Proofs for Participation Privacy, Receipt-Freeness, Ballot Privacy for the Helios Voting Scheme  David Bernhard, Oksana Kulyk, Melanie Volkamer</p>"},{"location":"ref_literature/#2018","title":"2018","text":"<p>E-voting system evaluation based on the Council of Europe recommendations: Helios Voting Luis Panizo, Mila Gasco\u0301, David Y. Marcos del Blanco, Jose\u0301 A. Hermida, Jordi Barrat and He\u0301ctor Ala\u0301iz IEEE Transactions on Emerging Topics in Computing, 2018</p> <p>Comparative Usability Evaluation of Cast-as-Intended Verification Approaches in Internet Voting Karola Marky, Oksana Kulyk, Melanie Volkamer</p> <p>Ballot secrecy: Security definition, sufficient conditions, and analysis of Helios  Ben Smyth</p> <p>Exploiting re-voting in the Helios election system  Maxime Meyera, Ben Smyth</p> <p>Verifiability of Helios Mixnet  Ben Smyth</p> <p>A foundation for secret, verifiable elections  Ben Smyth</p>"},{"location":"ref_literature/#2019","title":"2019","text":"<p>A protocolized, comparative study of Helios Voting and Scytl/iVote David Y Marcos del Blanco and Mila Gasco\u0301 Sixth International Conference on eDemocracy &amp; eGovernment (ICEDEG), 2019</p> <p>A Framework for I-Voting based on Helios and Public-Key Certificates  Noor Hamad Abid, Sufyan T. Faraj Al-Janabi</p> <p>A simple alternative to Benaloh challenge for the cast-as-intended property in Helios/Belenios  Ve\u0301ronique Cortier, Jannik Dreier, Pierrick Gaudry, Mathieu Turuani</p>"},{"location":"ref_literature/#2020","title":"2020","text":"<p>Fifty Shades of Ballot Privacy: Privacy against a Malicious Board  V\u00e9ronique Cortier, Joseph Lallemand, Bogdan Warinschi</p> <p>The Secure I-Voting System Helios++  Noor Hamad Abid, Sufyan T. Faraj Al-Janabi</p> <p>Verifiable Public Credentials for Stronger End-to-End Verifiability  Sevdenur Baloglu</p>"},{"location":"ref_literature/#2021","title":"2021","text":"<p>Helios: Attacks and Formal Models for Verifiability  Panagiotis Grontas</p> <p>Election Verifiability Revisited: Automated Security Proofs and Attacks on Helios and Belenios  Sevdenur Baloglu, Sergiu Bursuc, Sjouke Mauw, Jun Pang</p> <p>Election Verifiability: Cryptographic Definitions and an Analysis of Helios, Helios-C, and JCJ  Ben Smyth, Steven Frink, Michael R. Clarkson</p>"},{"location":"ref_models/","title":"Models","text":"<p>\"A model class represents a database table, and an instance of that class represents a particular record in the database table.\"  Django docs </p>"},{"location":"ref_models/#helios","title":"helios","text":""},{"location":"ref_models/#election-class","title":"Election class","text":"Field Type Default Comment uuid Char datatype Char legacy/Election short_name Char unique=True Set by admin name Char Set by admin election_type Char choices=[('election', 'Election'),('referendum', 'Referendum')],default=election private_p Boolean False description Text public_key LDObject null=True private_key LDObject null=True questions LDObject null=True eligibility LDObject null=True openreg Boolean False featured_p Boolean False use_voter_aliases Boolean False use_advanced_audit_features Boolean True randomize_answer_order Boolean False cast_url Char created_at DateTime auto_now_add=True modified_at DateTime auto_now_add=True frozen_at DateTime None, null=True archived_at DateTime None, null=True registration_starts_at DateTime None, null=True voting_starts_at DateTime None, null=True voting_ends_at DateTime None, null=True complaint_period_ends_at DateTime None, null=True tallying_starts_at DateTime None, null=True voting_started_at DateTime None, null=True voting_extended_until DateTime None, null=True voting_ended_at DateTime None, null=True tallying_started_at DateTime None, null=True tallying_finished_at DateTime None, null=True tallies_combined_at DateTime None, null=True result_released_at DateTime None, null=True voters_hash Char null=True encrypted_tally LDObject null=True result LDObject null=True result_proof jsonfield.JSON null=True help_email Email null=True election_info_url Char null=True voter_webid Char null=True"},{"location":"ref_models/#voterfile-class","title":"VoterFile class","text":"Field Type Default Comment voter_file File null=True This is a comment voter_file_content Text null=True uploaded_at DateTime auto_now_add=True processing_started_at DateTime null=True processing_finished_at DateTime null=True num_voters Integer null=True election ForeignKey"},{"location":"ref_models/#voter-class","title":"Voter class","text":"Field Type Default Comment uuid Char This is a comment voter_login_id Char null=True voter_password Char null=True voter_name Char null=True voter_email Char null=True alias Char null=True vote LDObject null=True vote_hash Char null=True cast_at DateTime null=True election ForeignKey user ForeignKey"},{"location":"ref_models/#electionlog-class","title":"ElectionLog class","text":"Field Type Default Comments log Char This is a comment at DateTime auto_now_add=True election ForeignKey"},{"location":"ref_models/#castvote-class","title":"CastVote class","text":"Field Type Default Comments vote LDObject This is a comment vote_hash Char vote_tinyhash Char null=Trueunique=True cast_at DateTime auto_now_add=True quarantined_p Boolean False released_from_quarantine_at DateTime null=True verified_at DateTime null=True invalidated_at DateTime null=True cast_ip GenericIPAddress null=True voter ForeignKey"},{"location":"ref_models/#auditedballot-class","title":"AuditedBallot class","text":"Field Type Default Comments raw_vote Text This is a comment vote_hash Char added_at DateTime auto_now_add=True election ForeignKey"},{"location":"ref_models/#trustee-class","title":"Trustee class","text":"Field Type Default Comments uuid Char This is a comment name Char email Email secret Char public_key LDObject null=True public_key_hash Char secret_key LDObject null=True pok LDObject null=True decryption_factors LDObject null=True decryption_proofs LDObject null=True election ForeignKey"},{"location":"ref_models/#helios_auth","title":"helios_auth","text":""},{"location":"ref_models/#user-class","title":"User class","text":"Field Type Default Comments user_type This is a comment user_id name null=True info jsonfield.JSONField token jsonfield.JSONField null=True admin_p Boolean False"},{"location":"ref_terms/","title":"Terms","text":""},{"location":"ref_terms/#audit","title":"audit","text":""},{"location":"ref_terms/#ballot","title":"ballot","text":"<p>A ballot is a document setting out the choices the voter is entitled to make.  It is presented to the voter in the voting booth.  The voter makes their choices and saves the encrypted ballot to their pod.  The application automatically sends a notification to the election admin for that election. </p>"},{"location":"ref_terms/#ballot-tracker","title":"ballot tracker","text":""},{"location":"ref_terms/#election","title":"election","text":"<p>An election which is created by an election admin.  Information relating to the election is stored on a database. The information includes:</p> <ul> <li>all voter webids</li> <li>encrypted ballots, once retrieved from pods</li> </ul>"},{"location":"ref_terms/#election-admin","title":"election admin","text":"<p>A person entitled to administer an election. An election admin may create an election.  An election admin who creates an election:</p> <p>A person is entitled to administer an election if ....</p>"},{"location":"ref_terms/#fingerprint","title":"fingerprint","text":""},{"location":"ref_terms/#user","title":"user","text":"<p>The currently logged in user who may be an election admin and / or a voter.  </p> <p>Or: the currently logged in user who will be a voter and may be an election admin.</p>"},{"location":"ref_terms/#voter","title":"voter","text":"<p>A person who is registered to vote in the current election.</p>"},{"location":"ref_terms/#voting-booth","title":"voting booth","text":""},{"location":"sec_helios/","title":"Helios cryptography","text":"<ul> <li>The election administrator sets up the election and generates a public - private key pair.</li> <li>The election has a set of trustees, each having a share of the private key but no-one holding the full private key.</li> <li>The public key is published.</li> <li>To cast a vote, the user runs a browser script that inputs her vote and creates a ballot that is encrypted with the public key of the election. The ballot includes a ZKP (Zero Knowledge Proof) that the ballot represents an allowed vote.</li> <li>The user can audit the ballot to check if it really represents a vote for her chosen candidate; if she elects to do this, the script provides her with the random data used in the ballot creation. She can then independently verify that the ballot was correctly constructed, but the ballot is now invalid and she has to create another one.</li> <li>When the voter has decided to cast her ballot, the voter\u2019s browser submits it along with her pseudo-identity to the server. The server checks the ZKPs of the ballots, and publishes them on a bulletin board.</li> <li>Individual voters can check that their ballots appear on the bulletin board. Any observer can check that the ballots that appear on the bulletin board represent allowed votes, by checking the ZKPs.</li> <li>The server homomorphically combines the ballots, and publishes the encrypted tally. Anyone can check that this tally is done correctly.</li> <li>The server submits the encrypted tally to each of the trustees, and obtains their share of the decryption key for that particular ciphertext, together with a proof that the key share is well-formed. The server publishes these key shares along with the proofs. Anyone can check the proofs.</li> <li>The server decrypts the tally and publishes the result. Anyone can check this decryption.</li> </ul> <p>There is also a good explanation in Usability Analysis of Helios - An Open Source Verifiable Remote Electronic Voting System</p> <ol> <li> <p>Helios documentation \u21a9</p> </li> <li> <p>This description is taken from https://bensmyth.com/files/Smyth10-definition-verifiability.LNCS.pdf \u21a9</p> </li> </ol>"},{"location":"todo/","title":"TODO","text":"<ul> <li> Lorem ipsum dolor sit amet, consectetur adipiscing elit</li> <li> Nulla lobortis egestas semper</li> <li> Curabitur elit nibh, euismod et ullamcorper at, iaculis feugiat est</li> <li> Vestibulum convallis sit amet nisi a tincidunt<ul> <li> In hac habitasse platea dictumst</li> <li> In scelerisque nibh non dolor mollis congue sed et metus</li> <li> Sed egestas felis quis elit dapibus, ac aliquet turpis mattis</li> <li> Praesent sed risus massa</li> </ul> </li> <li> Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque</li> <li> Nulla vel eros venenatis, imperdiet enim id, faucibus nisi</li> </ul>"},{"location":"use_admin_announces_results/","title":"Election admin announces results","text":""},{"location":"use_admin_tallies_ballots/","title":"Election admin tallies ballots","text":"<p>[ To be completed]</p>"},{"location":"use_create_election/","title":"Election admin creates an election","text":"<p>To create and administer an election, you will need to log in using Google, Facebook, Yahoo, or Twitter. Helios queries and retains only the basic information needed to authenticate you the next time around: your name, email address, and user ID. Helios will use this information to message you when your election requires attention.1</p> <p>As an election administrator, you have the power to designate who can vote, when the election starts, when the election stops, and when the results are released. Other than that, you have no power beyond what voters in your election have. This is by design.1</p> <p>On the home page for Helios, after logging in, click on <code>create election</code>.</p>"},{"location":"use_create_election/#create-election","title":"Create election","text":"<p>Complete the fields on the form and press <code>Next &gt;&gt;</code>.  Once the election is added it will be possible to come back and edit it up until you choose to freeze it.</p> Field Comment Short name no spaces, will be part of the URL for your election, e.g. my-club-2010 Name the pretty name for your election, e.g. My Club 2010 Election Description appears on main page for this election / referendum Type election / referendum; ??? Use voter aliases If selected, voter identities will be replaced with aliases, e.g. \"V12\", in the ballot tracking center Randomize answer order enable this if you want the answers to questions to appear in random order for each voter Private? A private election is only visible to registered voters. Help email address An email address voters should contact if they need help. Voting starts at UTC date and time when voting begins Voting ends at UTC date and time when voting ends <p>Pressing <code>Next &gt;&gt;</code> takes you to the main page for the election.</p>"},{"location":"use_create_election/#election-main-page","title":"Election main page","text":"<p>There is a statement about whether this election is featured on the front page.  In order to feature elections on the front page the user field <code>admin_p</code> in the helios_auth_user database table needs to be set to True.  Connect to the database in a termimal and run the SQL query:</p> <pre><code>UPDATE helios_auth_user SET admin_p = 't' WHERE user_id = [your_user_id];\n</code></pre> <p>From this page you can set up:</p> <ul> <li>the questions for voting on</li> <li>voters and ballots</li> <li>trustees</li> </ul>"},{"location":"use_create_election/#questions","title":"Questions","text":"<p>For each 'question' a voter may vote for one or more 'answers'.  A question might be 'Which two candidates should be elected?' and the available answers might be similar to candidate-one, candidate-two, candidate-three, candidate-four.  You can set how many answers may be chosen and whether the results should be expressed in absolute number of votes or relative numbers of votes (percentages). You can associate a link with each answer (for example a link to further information about a candidate).</p>"},{"location":"use_create_election/#voters-ballots","title":"Voters &amp; ballots","text":"<p>You may select one of:</p> <ul> <li>anyone can vote, a voter simply needs to log on, eg using Google authentication</li> <li>only the listed voters can vote</li> </ul> <p>If you choose the second option, you need to upload a list of voters contained in a csv file.</p>"},{"location":"use_create_election/#trustees","title":"Trustees","text":"<p>A trustee uses a private key to decrypt the result of the tally.  Helios is automatically a trustee.  It is not necessary to add further trustees, but if you do, it is important they retain their secret keys.  All secret keys will be required to decrypt the result.</p>"},{"location":"use_create_election/#freeze-ballot-and-open-election","title":"Freeze ballot and open election","text":"<p>Once you have set up the questions made your selection in the voters &amp; ballots section you can then freeze the election and open it for voting.  If you uploaded a list of voters, you can, in the Voters &amp; ballots section, send an email to all voters giving each of them their Voter ID and password.</p> <ol> <li> <p>https://heliosvoting.org/privacy \u21a9\u21a9</p> </li> </ol>"},{"location":"use_register_voter/","title":"Person registers as voter","text":"<p>When an election admin creates an election there is a 'Voters &amp; ballots' section where the admin can choose to:</p> <ul> <li>allow any member of the public to vote; or,</li> <li>upload a list of eligible voters</li> </ul> <p>If the election is open to any member of the public, the voter logs in using one of the Helios authentication options (Google, Facebook etc) prior to casting a vote.</p> <p>If eligibility is by way of being on a list of eligible voters - this list is uploaded by the election admin at the time of creating the election.  The Helios application does not provide a facility for a person to register as an eligible voter.</p>"},{"location":"use_voter_votes/","title":"Voter votes","text":"<p>The ballot casting application is implemented as a single-page web application using JavaScript. In particular, all necessary data is preloaded into the browser\u2019s memory and the JavaScript code up- dates the rendered HTML user interface when any links or buttons are clicked. As a result, no Internet access is required from the time the data is loaded onto the web browser, until one is ready to cast their vote. Anyone using a modern web browser running JavaScript (e.g. Firefox 2 or later), is able to cast a vote.1</p> <p>Admin has uploaded a voter list</p> <p>First, an invitation email containing the URL of the election page, an election fingerprint, the Voter-ID and the assigned password is sent to the voter.1 </p> <p>The voter clicks on the URL to open the \u2018Voting Booth\u2019 web-page which contains instructions on the voting procedure. After reading the instructions the voter presses the \u2018Start\u2019 button on this page to invoke a JavaScript session on their computer. The JavaScript code will lead the voter through the ballot casting procedure without a connection to the Internet. An empty ballot is first displayed. Upon making a selection, depending on the maximum number of candidates allowed, the voter gets a warning message pointing to the limit of the options. To continue the ballot casting process the voter clicks the \u2018Proceed\u2019 button and is forwarded to a page where all selected candidates are displayed. The voter can review their selection here, having then the chance to change this selection by clicking the link \u2018Update\u2019 or seal the ballot by pressing the button \u2018Confirm Choices and Encrypt Ballot\u2019.</p> <p>To continue the process, the voter can either submit or verify their encrypted vote by pressing the \u2018Proceed to Cast\u2019 button or the \u2018Audit\u2019 link respectively. Note that on this page, the smart ballot tracker is displayed along with two links to \u2018print\u2019 or \u2018email\u2019 the smart ballot tracker. The voter should use either of these options or record the smart ballot tracker for later verification. The voter may also copy and paste this information elsewhere. If the voter opts to verify, and clicks the \u2018audit\u2019 link, the JavaScript then displays a new page with the mathematical proofs of the encryption as well as instructions on how to verify the encrypted vote. The voter should copy the displayed information, click on the \u2018Ballot Verifier\u2019 link and paste the copied information into the \u2018Helios Single-Ballot Verifier\u2019 page which pops up. On clicking the \u2018Verify\u2019 button, they receive the results at the bottom of the page. As the \u2018Helios Single-Ballot Verifier\u2019 is an independent application with its own window, the voter can go back to the main ballot casting application at any time (e.g. by closing the verification application). In order to continue with the voting process, the voter clicks the \u2018back to voting\u2019 button. After that they will need to re-encrypt the ballot. The voter can then decide whether to cast the encrypted vote or to verify it again.</p> <p>If voter clicks the \u2018Proceed to Cast\u2019 button they are forwarded to the login page where the smart ballot tracker is displayed again. The voter enters the Voter-ID and the assigned password from the invitation email in order to proceed. On pressing the \u2018check credentials\u2019 button, the system confirms eligibility. If they are authenticated, the voter can in the next step finally cast the vote (by pressing the \u2018I am \u2014, cast this ballot\u2019 button). Alternatively they can click the \u2018cancel\u2019 button and cancel the election. A success message is displayed once the encrypted vote is successfully cast. The voter is redirected to the election information page by clicking the link \u2018return to election info\u2019. This page contains information on the election, verifying procedure and provides a link labeled \u2018Vote in this election\u2019 for the voter to start the election process afresh if they so choose. Finally, a confirmation email is sent to the voter.</p> <p>Ballot preparation and casting including individual verifiability are based on Benaloh\u2019s Simple Verifiable Voting Protocol, which is based on two aspects - separating ballot preparation/encryption and ballot casting as well as on Benaloh\u2019s challenge. The idea of separation means that the ballot can be viewed, selections can be made, the ballot can be encrypted and the encryption can be verified without having to authenticate oneself and, thus, without being an eligible voter. The voter only needs to be authenticated for the final ballot casting. An advantage of this approach is that everyone (including election observers) can verify the ballot preparation mechanism.</p> <p>In Benaloh\u2019s challenge, the system commits to the encrypted vote and then voters can decide whether they want to verify or cast the vote. The software cannot falsify information by encrypting the wrong candidate since it does not know whether the voter will either verify or cast the encrypted vote. Voters will notice during verification if the wrong candidate name is encrypted. In order to ensure that the software provides the same ciphertext for verifiability and ballot casting (instead of sending the properly encrypted vote to the system in case of verifiability and the ciphertext of a wrong candidate in case of ballot casting), it commits to its encryption by displaying a hash value of the ciphertext, which is the smart ballot tracker.</p> <p>Privacy requirements make it impossible to cast a verified vote. The verified encrypted vote therefore has to be re-encrypted. Correspondingly, a new hash value is computed and displayed. Thus, the voter cannot verify the encrypted vote they finally cast but must trust the system due to previous checks.</p> <p>Admin has set voting open to public</p> <p>If the admin has set up the election so that voting is open to any member of the public, a voter logs in using one of the Helios authentication options.  The voting process is the same as for a voter who is on a list that is uploaded by an election admin.</p> <ol> <li> <p>This explanation of the voter process is taken from Usability Analysis of Helios - An Open Source Verifiable Remote Electronic Voting System \u21a9\u21a9</p> </li> </ol>"}]}