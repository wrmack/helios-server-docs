{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Warwick McNaughton's Helios server documentation Github: https://github.com/wrmack/helios-server-docs For earlier documentation see: Helios Voting Installation Helios Voting Docs Community support: Helios Voting Google Group Motivation Helios is an important milestone in the development of secure online voting. As someone who is involved in running elections at a local government level this is something I am keen to see being progressed. If people are going to run elections online it is important they use the most secure systems available. The motivation for creating this documentation is to make Helios more accessible for those wishing to deploy Helios. It is based on my own exploration of Helios and does not purport to be official documentation. Source The documentation source code is on Github: https://github.com/wrmack/helios-server-docs Please leave any questions about this documentation or suggestions for improving this documentation under Discussions . Also share your own experience with setting up an election. Please leave any comments about technical problems running this documentation under Issues . Warwick","title":"Home"},{"location":"#helios-server-documentation","text":"Github: https://github.com/wrmack/helios-server-docs For earlier documentation see: Helios Voting Installation Helios Voting Docs Community support: Helios Voting Google Group Motivation Helios is an important milestone in the development of secure online voting. As someone who is involved in running elections at a local government level this is something I am keen to see being progressed. If people are going to run elections online it is important they use the most secure systems available. The motivation for creating this documentation is to make Helios more accessible for those wishing to deploy Helios. It is based on my own exploration of Helios and does not purport to be official documentation. Source The documentation source code is on Github: https://github.com/wrmack/helios-server-docs Please leave any questions about this documentation or suggestions for improving this documentation under Discussions . Also share your own experience with setting up an election. Please leave any comments about technical problems running this documentation under Issues . Warwick","title":"Helios server documentation"},{"location":"acknowledgements/","text":"Acknowledgements","title":"Acknowledgements"},{"location":"acknowledgements/#acknowledgements","text":"","title":"Acknowledgements"},{"location":"con_coercion/","text":"Coercion A voter should not be intimidated (coerced) into voting the way the coercer wants. Democracy depends on individuals being able to freely cast their votes without coercion, bribery or any form of improper influence. A voter's vote should be secret to protect the voter from coercion: Ballot Secrecy : the voting system must not reveal who the voter voted for. Receipt-freeness : the voting system should not give the voter any evidence to prove to a third party how she voted. Coercion-Resistance : the voter should be able to cast a vote for her intended choice even while appearing to cooperate with a coercer. 1 An Overview of End-to-End Verifiable Voting Systems Syed Taha Ali and Judy Murray. (2016) \u21a9","title":"Coercion"},{"location":"con_coercion/#coercion","text":"A voter should not be intimidated (coerced) into voting the way the coercer wants. Democracy depends on individuals being able to freely cast their votes without coercion, bribery or any form of improper influence. A voter's vote should be secret to protect the voter from coercion: Ballot Secrecy : the voting system must not reveal who the voter voted for. Receipt-freeness : the voting system should not give the voter any evidence to prove to a third party how she voted. Coercion-Resistance : the voter should be able to cast a vote for her intended choice even while appearing to cooperate with a coercer. 1 An Overview of End-to-End Verifiable Voting Systems Syed Taha Ali and Judy Murray. (2016) \u21a9","title":"Coercion"},{"location":"con_e2ev/","text":"End-to-end verifiability Voters and candidates should not have to blindly trust that electronic election technology works. It might be compromised by an attacker or it might be incorrectly coded. How do voters and candidates know the result is correct? End-to-end verifiability (E2E-V) provides for voters and candidates to verify an election result is correct. 1 2 Verifiability is generally exhibited by: Individual Verifiability : a voter can verify that her vote is included in the set of all cast votes. Universal Verifiability : an observer can verify that the tally has been correctly computed from the set of all cast votes. Verifiability can be acheived as follows: Cast As Intended : voters make their selections and, at the time of vote casting, can get convincing evidence that their encrypted votes accurately reflect their choices; Recorded As Cast : voters or their designees can check that their encrypted votes have been correctly included, by finding exactly the encrypted value they cast on a public list of encrypted cast votes; and Tallied As Recorded : any member of the public can check that all the published encrypted votes are correctly included in the tally, without knowing how any individual voted. End-to-end verifiability Josh Benaloh, Microsoft Research. Ronald Rivest, MIT. Peter Y. A. Ryan University of Luxembourg. Philip Stark, UC Berkeley. Vanessa Teague, University of Melbourne. Poorvi Vora, George Washington University. (2014) \u21a9 An Overview of End-to-End Verifiable Voting Systems Syed Taha Ali and Judy Murray. (2016) \u21a9 The Future of Voting: End-to-End Verifiable Internet Voting - Specification and Feasibility Study U.S. Vote Foundation (2015) \u21a9","title":"Verifiability"},{"location":"con_e2ev/#end-to-end-verifiability","text":"Voters and candidates should not have to blindly trust that electronic election technology works. It might be compromised by an attacker or it might be incorrectly coded. How do voters and candidates know the result is correct? End-to-end verifiability (E2E-V) provides for voters and candidates to verify an election result is correct. 1 2 Verifiability is generally exhibited by: Individual Verifiability : a voter can verify that her vote is included in the set of all cast votes. Universal Verifiability : an observer can verify that the tally has been correctly computed from the set of all cast votes. Verifiability can be acheived as follows: Cast As Intended : voters make their selections and, at the time of vote casting, can get convincing evidence that their encrypted votes accurately reflect their choices; Recorded As Cast : voters or their designees can check that their encrypted votes have been correctly included, by finding exactly the encrypted value they cast on a public list of encrypted cast votes; and Tallied As Recorded : any member of the public can check that all the published encrypted votes are correctly included in the tally, without knowing how any individual voted. End-to-end verifiability Josh Benaloh, Microsoft Research. Ronald Rivest, MIT. Peter Y. A. Ryan University of Luxembourg. Philip Stark, UC Berkeley. Vanessa Teague, University of Melbourne. Poorvi Vora, George Washington University. (2014) \u21a9 An Overview of End-to-End Verifiable Voting Systems Syed Taha Ali and Judy Murray. (2016) \u21a9 The Future of Voting: End-to-End Verifiable Internet Voting - Specification and Feasibility Study U.S. Vote Foundation (2015) \u21a9","title":"End-to-end verifiability"},{"location":"con_helios/","text":"How Helios works. (A general description is provided in Wikipedia .) Helios is a truly verifiable voting system, which means that: Alice can verify that her vote was correctly captured, all captured votes are displayed (in encrypted form) for all to see. anyone can verify that the captured votes were correctly tallied. 1 An election is created by naming a set of trustees and running a protocol that provides each of them with a share of the secret part of a public key pair. The public part of the key is published. Each of the eligible voters is also provided with a private pseudo-identity. The steps that participants take during a run of Helios are as follows. 2 To cast a vote, the user runs a browser script that inputs her vote and creates a ballot that is encrypted with the public key of the election. The ballot includes a ZKP (Zero Knowledge Proof) that the ballot represents an allowed vote (this is needed because the ballots are never decrypted individually). The user can audit the ballot to check if it really represents a vote for her chosen candidate; if she elects to do this, the script provides her with the random data used in the ballot creation. She can then independently verify that the ballot was correctly constructed, but the ballot is now invalid and she has to create another one. When the voter has decided to cast her ballot, the voter\u2019s browser submits it along with her pseudo-identity to the server. The server checks the ZKPs of the ballots, and publishes them on a bulletin board. Individual voters can check that their ballots appear on the bulletin board. Any observer can check that the ballots that appear on the bulletin board represent allowed votes, by checking the ZKPs. The server homomorphically combines the ballots, and publishes the encrypted tally. Anyone can check that this tally is done correctly. The server submits the encrypted tally to each of the trustees, and obtains their share of the decryption key for that particular ciphertext, together with a proof that the key share is well-formed. The server publishes these key shares along with the proofs. Anyone can check the proofs. The server decrypts the tally and publishes the result. Anyone can check this decryption. There is also a good explanation in Usability Analysis of Helios - An Open Source Verifiable Remote Electronic Voting System Helios documentation \u21a9 This description is taken from https://bensmyth.com/files/Smyth10-definition-verifiability.LNCS.pdf \u21a9","title":"How Helios works."},{"location":"con_helios/#how-helios-works","text":"(A general description is provided in Wikipedia .) Helios is a truly verifiable voting system, which means that: Alice can verify that her vote was correctly captured, all captured votes are displayed (in encrypted form) for all to see. anyone can verify that the captured votes were correctly tallied. 1 An election is created by naming a set of trustees and running a protocol that provides each of them with a share of the secret part of a public key pair. The public part of the key is published. Each of the eligible voters is also provided with a private pseudo-identity. The steps that participants take during a run of Helios are as follows. 2 To cast a vote, the user runs a browser script that inputs her vote and creates a ballot that is encrypted with the public key of the election. The ballot includes a ZKP (Zero Knowledge Proof) that the ballot represents an allowed vote (this is needed because the ballots are never decrypted individually). The user can audit the ballot to check if it really represents a vote for her chosen candidate; if she elects to do this, the script provides her with the random data used in the ballot creation. She can then independently verify that the ballot was correctly constructed, but the ballot is now invalid and she has to create another one. When the voter has decided to cast her ballot, the voter\u2019s browser submits it along with her pseudo-identity to the server. The server checks the ZKPs of the ballots, and publishes them on a bulletin board. Individual voters can check that their ballots appear on the bulletin board. Any observer can check that the ballots that appear on the bulletin board represent allowed votes, by checking the ZKPs. The server homomorphically combines the ballots, and publishes the encrypted tally. Anyone can check that this tally is done correctly. The server submits the encrypted tally to each of the trustees, and obtains their share of the decryption key for that particular ciphertext, together with a proof that the key share is well-formed. The server publishes these key shares along with the proofs. Anyone can check the proofs. The server decrypts the tally and publishes the result. Anyone can check this decryption. There is also a good explanation in Usability Analysis of Helios - An Open Source Verifiable Remote Electronic Voting System Helios documentation \u21a9 This description is taken from https://bensmyth.com/files/Smyth10-definition-verifiability.LNCS.pdf \u21a9","title":"How Helios works."},{"location":"deploy_aws_walkthrough/","text":"Deploying Helios to AWS (Amazon Web Services) Introduction AWS provides a large range of services. This deployment uses the following services: Elastic Compute, or EC2, which provides a virtual server instance Elastic Block Store, or EBS, which provides the 'hard drive' for the server instance Elastic IP Address, which provides a persistent IP address (the IP address associated with an EC2 instance may change if the instance is stopped and restarted) Route 53 for obtaining a domain name (required for setting up https) Simple Email Service, or SES, for sending emails Identity and Access Management, or IAM, for obtaining keys for programmatic access to the SES API All of these services are in the free tier except for a domain name which costs $12 USD per year for a .com name. The free tier includes services which are always free and services which are only free for the first 12 months. The most expensive service of the above is the EC2 instance which is free for 12 months. Once outside the free tier's 12 month period if you are paying on demand you might consider stopping the instance when you are not using it (eg if you are only using it for development purposes). Data persists provided the EBS remains attached. Other options might include: Lightsail, instead of EC2, which provides an easier setup process and has an option for Django frameworks Relational Database Service, or RDS, for providing a postgresql database (our deployment will simply install postgresql on the EC2 instance) This deployment assumes: you have created an account on AWS and are logged into the management console you have set up authentication for Google OAuth (to allow logging in to Helios) Caveat: this deployment has not been tested with a real election. It may help to get you started. Create an EC2 instance click on Services in the top menu bar and from the drop-down select EC2 under Compute click on the red button Launch instance select the free tier Amazon Linux 2 AMI (should be the very first one) for instance type select the free tier t2.micro then click the button Configure Instance no changes, click button Add Storage ; this is the EBS volume to be attached to your EC2 instance with a default size of 8 GB no changes, click button Add Tags ; adding tags is optional click button Configure Security Group which configures which ports should be open add these rules to the default SSH one: Postgresql (from drop-down) (port 5432, source 0.0.0.0/0) HTTP HTTPS click button Review and Launch click button Launch which pops up a window for creating a key pair create a new key pair, give it a name and download the private key (.pem file), then click Launch click on View Instances to go to the EC2 Instances page click on the Instance ID to view detailed information about the instance get an Elastic IP which will persist: in left side-bar click Elastic IPs click red button Allocate Elastic IP address click red button Allocate on Elastic IP addresses page select the Elastic IP address then in the Actions drop-down select Associate Elastic IP address in the Instance box select your instance then click the red button Associate you now have remote SSH access to your instance using its Elastic IP address or Public IPv4 DNS EC2 users are all ec2-user ssh -i path_to_keypair.pem ec2-user@elastic_ip_address the following shows the virtual disk space on your EBS volume: sudo df -h / Filesystem Size Used Avail Use% Mounted on /dev/xvda1 8.0G 1.4G 6.7G 18% / Upload Helios download master branch of Helios to a local directory use rsync to upload to your EC2 instance (substitute correct values for path_to_keypair.pem, path_to/helios-server-master, elastic_ip_address): rsync -av -e \"ssh -i path_to_keypair.pem\" path_to/helios-server-master ec2-user@elastic_ip_address:/home/ec2-user Install python, postgresql, helios requirements, rabbitmq do the following: # ssh into your instance (if not already in it) ssh -i path_to_keypair.pem ec2-user@elastic_ip_address # python3 sudo yum install python3 -y # postgresql sudo yum install postgresql-server -y sudo postgresql-setup initdb sudo systemctl enable postgresql.service sudo systemctl start postgresql.service sudo -i -u postgres psql postgres CREATE USER \"ec2-user\" WITH SUPERUSER; CREATE DATABASE helios WITH OWNER \"ec2-user\"; \\q exit # rabbitmq curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash sudo yum install erlang -y sudo yum install rabbitmq-server -y sudo /sbin/service rabbitmq-server start # requirements.txt sudo yum install gcc -y # Required to build psycopg2 from source sudo yum install python3-devel -y # Required to build psycopg2 from source sudo yum install postgresql-devel -y # Required to build psycopg2 from source cd ~/helios-server-master python3 -m venv venv source venv/bin/activate python3 -m pip install wheel python3 -m pip install -r requirements.txt python3 -m pip install django-environ # So can use environ module python3 manage.py migrate # Initialise the helios database # start celery (still in venv environment) celery -A helios worker -l INFO Nginx if you wish to leave celery running then open another termimal and ssh -i path_to_keypair.pem ec2-user@elastic_ip_address install Nginx sudo amazon-linux-extras install nginx1 -y create /etc/systemd/system/gunicorn.socket sudo nano /etc/systemd/system/gunicorn.socket content of gunicorn.socket [Unit] Description=gunicorn socket [Socket] ListenStream=/run/gunicorn.sock [Install] WantedBy=sockets.target create /etc/systemd/system/gunicorn.service sudo nano /etc/systemd/system/gunicorn.service content of gunicorn.service [Unit] Description=gunicorn daemon Requires=gunicorn.socket After=network.target [Service] User=ec2-user Group=ec2-user WorkingDirectory=/home/ec2-user/helios-server-master ExecStart=/home/ec2-user/helios-server-master/venv/bin/gunicorn \\ --access-logfile - \\ --workers 3 \\ --bind unix:/run/gunicorn.sock \\ wsgi:application [Install] WantedBy=multi-user.target open /etc/nginx/nginx.conf sudo nano /etc/nginx/nginx.conf content of nginx.conf user nginx; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; include /usr/share/nginx/modules/*.conf; events { worker_connections 1024; } http { log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 4096; include /etc/nginx/mime.types; default_type application/octet-stream; include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; server { listen 80; listen [::]:80; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } } create directory /etc/nginx/sites-available sudo mkdir /etc/nginx/sites-available create /etc/nginx/sites-available/helios sudo nano /etc/nginx/sites-available/helios content of helios (replace your_elastic_ip with your own) server { listen 80; server_name your_elastic_ip; location = /favicon.ico { access_log off; log_not_found off; } location / { proxy_pass http://unix:/run/gunicorn.sock; } } link sites-enabled to sites-available sudo ln -s /etc/nginx/sites-available /etc/nginx/sites-enabled Update settings.py these keys should have these values (replace your_elastic_ip with your own) ALLOWED_HOSTS = ['your_elastic_ip','localhost'] CELERY_BROKER_URL = get_from_env('CELERY_BROKER_URL', 'amqp://localhost') Check if site loads - 1 start services sudo systemctl start gunicorn.socket sudo systemctl enable gunicorn.socket sudo systemctl daemon-reload sudo systemctl start gunicorn.service sudo systemctl start nginx in your browser go to http://your_elastic_ip_address it will not be possible to log in because we have not yet set up Google authentication which requires SSL options for troubleshooting and viewing error messages: sudo nginx -t # Checks configuration of Nginx sudo systemctl status nginx.service sudo cat /var/log/nginx/error.log sudo cat /var/log/nginx/access.log sudo journalctl -xe Convert site to https we use certbot which blacklists AWS instance names (because they are ephemeral) so we need a permanent domain name there is a cost of $12 USD per year for a .com name obtain a domain name by going to the Route 53 service click the Services drop-down on the AWS menubar select Route 53 under Networking and Content Delivery in the left side-bar select Registered domains then click the blue button Register Domain follow the prompts to purchase a domain name back on the Route 53 home page select Hosted zones in the left side-bar under Quick create record create a subdomain name (eg helios to give helios.your_domain.com) record type should be A and Value type should be your elastic ip click the red button Create records you have now associated your sub-domain with your elastic ip address update /etc/nginx/sites-available/helios to automatically redirect http requests to https and add a server block for https (replace your_domain_name with your own one - there are four): server { listen 80; server_name your_domain_name; return 301 https://$host$request_uri; # Causes http to redirect to https } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name your_domain_name; ssl_certificate \"/etc/letsencrypt/live/your_domain_name/cert.pem\"; ssl_certificate_key \"/etc/letsencrypt/live/your_domain_name/privkey.pem\"; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:SEED:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!RSAPSK:!aDH:!aECDH:!EDH-DSS-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA:!SRP; ssl_prefer_server_ciphers on; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } install certbot sudo python3 -m venv /opt/certbot/ sudo /opt/certbot/bin/pip install --upgrade pip sudo /opt/certbot/bin/pip install certbot certbot-nginx sudo ln -s /opt/certbot/bin/certbot /usr/bin/certbot sudo certbot --nginx # Automatic renewal - optional echo \"0 0,12 * * * root /opt/certbot/bin/python -c 'import random; import time; time.sleep(random.random() * 3600)' && certbot renew -q\" | sudo tee -a /etc/crontab > /dev/null that should automatically check for correct configuration, if it fails for any reason you may need to manually put the certificate and key in the correct directory you should have a .env file in your helios root directory for keeping secret credentials: GOOGLESECRET=xxxxxxxxxxxxxxxxxx GOOGLEID=xxxxxxxxxxxxxxxxxx update settings.py - these seem to be the key changes to make: # Read in secrets from your .env file import environ env = environ.Env() environ.Env.read_env() GOOGLESECRET = env('GOOGLESECRET') GOOGLEID = env('GOOGLEID') DEBUG = (get_from_env('DEBUG', '0') == '0') ALLOWED_HOSTS = ['localhost',''your_elastic_ip','your_domain_name'] URL_HOST = get_from_env(\"URL_HOST\", \"https://your_domain_name).rstrip(\"/\") GOOGLE_CLIENT_ID = get_from_env('GOOGLE_CLIENT_ID', GOOGLEID) GOOGLE_CLIENT_SECRET = get_from_env('GOOGLE_CLIENT_SECRET', GOOGLESECRET) if you use Google for authentication you will need to add your new domain name to authorised urls in Google credentials Check if site loads - 2 start celery in venv environment if not already running celery -A helios worker -l INFO restart all services sudo systemctl restart gunicorn.socket sudo systemctl daemon-reload sudo systemctl restart gunicorn.service sudo systemctl restart nginx in your browser go to https://your_domain_name if that loads without error check that http redirects to https: http://your_domain_name try logging on with Google if all this succeeds you should be able to set up an election but not be able to email voters yet Set up email AWS provides the AWS Simple Email Serivce (SES) there is a django backend ( django-SES ) that talks to this service to use this, it is necessary to have programmatic access to AWS SES APIs to create a user who has access, go to the AWS service IAM (in the drop-down list of services under Security, Identity & Compliance ) in the left side-bar select Users then click the blue button Add user provide a user name and select Programmatic access select Attach existing policies directly then search for SES and select AmazonSESFullAccess (optional) add a tag review and click blue button Create user important: record the Access key ID and Secret access key in your .env file add AWS_SES_ACCESS_KEY_ID=your_access_key_id AWS_SES_SECRET_ACCESS_KEY=your_secret_access_key in settings.py include the following entries: AWS_SES_REGION_NAME = 'us-east-1' # change this if you use a different region AWS_SES_REGION_ENDPOINT = 'email.us-east-1.amazonaws.com' # change this if you use a different region AWS_SES_ACCESS_KEY_ID = env('AWS_SES_ACCESS_KEY_ID') AWS_SES_SECRET_ACCESS_KEY = env('AWS_SES_SECRET_ACCESS_KEY') EMAIL_BACKEND = 'django_ses.SESBackend' AWS SES initially places your SES account in a sandbox (it has restrictions) and requires email senders to be verified on the Amazon SES page, in the left side-bar, select Verified identities and add email addresses for verification the system sends an email to each address asking for verification by reply make sure DEFAULT_FROM_EMAIL in settings.py is a verified email address optionally, in your venv environment, test email works with: python manage.py shell >>> from django.core.mail import send_mail >>> send_mail('Subject', 'Message', 'one_of_your_verified_email_addresses_as_sender', ['one_of_your_verified_email_addresses_as_receiver']) Check if site loads - 3 start celery in venv environment if not already running celery -A helios worker -l INFO restart all services sudo systemctl restart gunicorn.socket sudo systemctl daemon-reload sudo systemctl restart gunicorn.service sudo systemctl restart nginx in your browser go to https://your_domain_name Daemonise Celery to start automatically create /etc/systemd/system/celery.service sudo nano /etc/systemd/system/celery.service content of celery.service: [Unit] Description=Celery Service After=network.target [Service] User=ec2-user Group=ec2-user WorkingDirectory=/home/ec2-user/helios-server-master ExecStart=/home/ec2-user/helios-server-master/venv/bin/celery -A helios worker -l INFO [Install] WantedBy=multi-user.target then sudo systemctl daemon-reload # Get systemd to recognise celery.service sudo systemctl enable celery.service # Get celery.servce to run whenver rebooted sudo systemctl start celery.service # Start Celery Troubleshooting Postgresql you may need to edit pg_hba.conf (located at /var/lib/pgsql/data/pg_hba.conf) for lines commencing host change the METHOD from ident to md5","title":"AWS walk-through"},{"location":"deploy_aws_walkthrough/#introduction","text":"AWS provides a large range of services. This deployment uses the following services: Elastic Compute, or EC2, which provides a virtual server instance Elastic Block Store, or EBS, which provides the 'hard drive' for the server instance Elastic IP Address, which provides a persistent IP address (the IP address associated with an EC2 instance may change if the instance is stopped and restarted) Route 53 for obtaining a domain name (required for setting up https) Simple Email Service, or SES, for sending emails Identity and Access Management, or IAM, for obtaining keys for programmatic access to the SES API All of these services are in the free tier except for a domain name which costs $12 USD per year for a .com name. The free tier includes services which are always free and services which are only free for the first 12 months. The most expensive service of the above is the EC2 instance which is free for 12 months. Once outside the free tier's 12 month period if you are paying on demand you might consider stopping the instance when you are not using it (eg if you are only using it for development purposes). Data persists provided the EBS remains attached. Other options might include: Lightsail, instead of EC2, which provides an easier setup process and has an option for Django frameworks Relational Database Service, or RDS, for providing a postgresql database (our deployment will simply install postgresql on the EC2 instance) This deployment assumes: you have created an account on AWS and are logged into the management console you have set up authentication for Google OAuth (to allow logging in to Helios) Caveat: this deployment has not been tested with a real election. It may help to get you started.","title":"Introduction"},{"location":"deploy_aws_walkthrough/#create-an-ec2-instance","text":"click on Services in the top menu bar and from the drop-down select EC2 under Compute click on the red button Launch instance select the free tier Amazon Linux 2 AMI (should be the very first one) for instance type select the free tier t2.micro then click the button Configure Instance no changes, click button Add Storage ; this is the EBS volume to be attached to your EC2 instance with a default size of 8 GB no changes, click button Add Tags ; adding tags is optional click button Configure Security Group which configures which ports should be open add these rules to the default SSH one: Postgresql (from drop-down) (port 5432, source 0.0.0.0/0) HTTP HTTPS click button Review and Launch click button Launch which pops up a window for creating a key pair create a new key pair, give it a name and download the private key (.pem file), then click Launch click on View Instances to go to the EC2 Instances page click on the Instance ID to view detailed information about the instance get an Elastic IP which will persist: in left side-bar click Elastic IPs click red button Allocate Elastic IP address click red button Allocate on Elastic IP addresses page select the Elastic IP address then in the Actions drop-down select Associate Elastic IP address in the Instance box select your instance then click the red button Associate you now have remote SSH access to your instance using its Elastic IP address or Public IPv4 DNS EC2 users are all ec2-user ssh -i path_to_keypair.pem ec2-user@elastic_ip_address the following shows the virtual disk space on your EBS volume: sudo df -h / Filesystem Size Used Avail Use% Mounted on /dev/xvda1 8.0G 1.4G 6.7G 18% /","title":"Create an EC2 instance"},{"location":"deploy_aws_walkthrough/#upload-helios","text":"download master branch of Helios to a local directory use rsync to upload to your EC2 instance (substitute correct values for path_to_keypair.pem, path_to/helios-server-master, elastic_ip_address): rsync -av -e \"ssh -i path_to_keypair.pem\" path_to/helios-server-master ec2-user@elastic_ip_address:/home/ec2-user","title":"Upload Helios"},{"location":"deploy_aws_walkthrough/#install-python-postgresql-helios-requirements-rabbitmq","text":"do the following: # ssh into your instance (if not already in it) ssh -i path_to_keypair.pem ec2-user@elastic_ip_address # python3 sudo yum install python3 -y # postgresql sudo yum install postgresql-server -y sudo postgresql-setup initdb sudo systemctl enable postgresql.service sudo systemctl start postgresql.service sudo -i -u postgres psql postgres CREATE USER \"ec2-user\" WITH SUPERUSER; CREATE DATABASE helios WITH OWNER \"ec2-user\"; \\q exit # rabbitmq curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash sudo yum install erlang -y sudo yum install rabbitmq-server -y sudo /sbin/service rabbitmq-server start # requirements.txt sudo yum install gcc -y # Required to build psycopg2 from source sudo yum install python3-devel -y # Required to build psycopg2 from source sudo yum install postgresql-devel -y # Required to build psycopg2 from source cd ~/helios-server-master python3 -m venv venv source venv/bin/activate python3 -m pip install wheel python3 -m pip install -r requirements.txt python3 -m pip install django-environ # So can use environ module python3 manage.py migrate # Initialise the helios database # start celery (still in venv environment) celery -A helios worker -l INFO","title":"Install python, postgresql, helios requirements, rabbitmq"},{"location":"deploy_aws_walkthrough/#nginx","text":"if you wish to leave celery running then open another termimal and ssh -i path_to_keypair.pem ec2-user@elastic_ip_address install Nginx sudo amazon-linux-extras install nginx1 -y create /etc/systemd/system/gunicorn.socket sudo nano /etc/systemd/system/gunicorn.socket content of gunicorn.socket [Unit] Description=gunicorn socket [Socket] ListenStream=/run/gunicorn.sock [Install] WantedBy=sockets.target create /etc/systemd/system/gunicorn.service sudo nano /etc/systemd/system/gunicorn.service content of gunicorn.service [Unit] Description=gunicorn daemon Requires=gunicorn.socket After=network.target [Service] User=ec2-user Group=ec2-user WorkingDirectory=/home/ec2-user/helios-server-master ExecStart=/home/ec2-user/helios-server-master/venv/bin/gunicorn \\ --access-logfile - \\ --workers 3 \\ --bind unix:/run/gunicorn.sock \\ wsgi:application [Install] WantedBy=multi-user.target open /etc/nginx/nginx.conf sudo nano /etc/nginx/nginx.conf content of nginx.conf user nginx; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; include /usr/share/nginx/modules/*.conf; events { worker_connections 1024; } http { log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 4096; include /etc/nginx/mime.types; default_type application/octet-stream; include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; server { listen 80; listen [::]:80; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } } create directory /etc/nginx/sites-available sudo mkdir /etc/nginx/sites-available create /etc/nginx/sites-available/helios sudo nano /etc/nginx/sites-available/helios content of helios (replace your_elastic_ip with your own) server { listen 80; server_name your_elastic_ip; location = /favicon.ico { access_log off; log_not_found off; } location / { proxy_pass http://unix:/run/gunicorn.sock; } } link sites-enabled to sites-available sudo ln -s /etc/nginx/sites-available /etc/nginx/sites-enabled","title":"Nginx"},{"location":"deploy_aws_walkthrough/#update-settingspy","text":"these keys should have these values (replace your_elastic_ip with your own) ALLOWED_HOSTS = ['your_elastic_ip','localhost'] CELERY_BROKER_URL = get_from_env('CELERY_BROKER_URL', 'amqp://localhost')","title":"Update settings.py"},{"location":"deploy_aws_walkthrough/#check-if-site-loads-1","text":"start services sudo systemctl start gunicorn.socket sudo systemctl enable gunicorn.socket sudo systemctl daemon-reload sudo systemctl start gunicorn.service sudo systemctl start nginx in your browser go to http://your_elastic_ip_address it will not be possible to log in because we have not yet set up Google authentication which requires SSL options for troubleshooting and viewing error messages: sudo nginx -t # Checks configuration of Nginx sudo systemctl status nginx.service sudo cat /var/log/nginx/error.log sudo cat /var/log/nginx/access.log sudo journalctl -xe","title":"Check if site loads - 1"},{"location":"deploy_aws_walkthrough/#convert-site-to-https","text":"we use certbot which blacklists AWS instance names (because they are ephemeral) so we need a permanent domain name there is a cost of $12 USD per year for a .com name obtain a domain name by going to the Route 53 service click the Services drop-down on the AWS menubar select Route 53 under Networking and Content Delivery in the left side-bar select Registered domains then click the blue button Register Domain follow the prompts to purchase a domain name back on the Route 53 home page select Hosted zones in the left side-bar under Quick create record create a subdomain name (eg helios to give helios.your_domain.com) record type should be A and Value type should be your elastic ip click the red button Create records you have now associated your sub-domain with your elastic ip address update /etc/nginx/sites-available/helios to automatically redirect http requests to https and add a server block for https (replace your_domain_name with your own one - there are four): server { listen 80; server_name your_domain_name; return 301 https://$host$request_uri; # Causes http to redirect to https } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name your_domain_name; ssl_certificate \"/etc/letsencrypt/live/your_domain_name/cert.pem\"; ssl_certificate_key \"/etc/letsencrypt/live/your_domain_name/privkey.pem\"; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:SEED:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!RSAPSK:!aDH:!aECDH:!EDH-DSS-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA:!SRP; ssl_prefer_server_ciphers on; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } install certbot sudo python3 -m venv /opt/certbot/ sudo /opt/certbot/bin/pip install --upgrade pip sudo /opt/certbot/bin/pip install certbot certbot-nginx sudo ln -s /opt/certbot/bin/certbot /usr/bin/certbot sudo certbot --nginx # Automatic renewal - optional echo \"0 0,12 * * * root /opt/certbot/bin/python -c 'import random; import time; time.sleep(random.random() * 3600)' && certbot renew -q\" | sudo tee -a /etc/crontab > /dev/null that should automatically check for correct configuration, if it fails for any reason you may need to manually put the certificate and key in the correct directory you should have a .env file in your helios root directory for keeping secret credentials: GOOGLESECRET=xxxxxxxxxxxxxxxxxx GOOGLEID=xxxxxxxxxxxxxxxxxx update settings.py - these seem to be the key changes to make: # Read in secrets from your .env file import environ env = environ.Env() environ.Env.read_env() GOOGLESECRET = env('GOOGLESECRET') GOOGLEID = env('GOOGLEID') DEBUG = (get_from_env('DEBUG', '0') == '0') ALLOWED_HOSTS = ['localhost',''your_elastic_ip','your_domain_name'] URL_HOST = get_from_env(\"URL_HOST\", \"https://your_domain_name).rstrip(\"/\") GOOGLE_CLIENT_ID = get_from_env('GOOGLE_CLIENT_ID', GOOGLEID) GOOGLE_CLIENT_SECRET = get_from_env('GOOGLE_CLIENT_SECRET', GOOGLESECRET) if you use Google for authentication you will need to add your new domain name to authorised urls in Google credentials","title":"Convert site to https"},{"location":"deploy_aws_walkthrough/#check-if-site-loads-2","text":"start celery in venv environment if not already running celery -A helios worker -l INFO restart all services sudo systemctl restart gunicorn.socket sudo systemctl daemon-reload sudo systemctl restart gunicorn.service sudo systemctl restart nginx in your browser go to https://your_domain_name if that loads without error check that http redirects to https: http://your_domain_name try logging on with Google if all this succeeds you should be able to set up an election but not be able to email voters yet","title":"Check if site loads - 2"},{"location":"deploy_aws_walkthrough/#set-up-email","text":"AWS provides the AWS Simple Email Serivce (SES) there is a django backend ( django-SES ) that talks to this service to use this, it is necessary to have programmatic access to AWS SES APIs to create a user who has access, go to the AWS service IAM (in the drop-down list of services under Security, Identity & Compliance ) in the left side-bar select Users then click the blue button Add user provide a user name and select Programmatic access select Attach existing policies directly then search for SES and select AmazonSESFullAccess (optional) add a tag review and click blue button Create user important: record the Access key ID and Secret access key in your .env file add AWS_SES_ACCESS_KEY_ID=your_access_key_id AWS_SES_SECRET_ACCESS_KEY=your_secret_access_key in settings.py include the following entries: AWS_SES_REGION_NAME = 'us-east-1' # change this if you use a different region AWS_SES_REGION_ENDPOINT = 'email.us-east-1.amazonaws.com' # change this if you use a different region AWS_SES_ACCESS_KEY_ID = env('AWS_SES_ACCESS_KEY_ID') AWS_SES_SECRET_ACCESS_KEY = env('AWS_SES_SECRET_ACCESS_KEY') EMAIL_BACKEND = 'django_ses.SESBackend' AWS SES initially places your SES account in a sandbox (it has restrictions) and requires email senders to be verified on the Amazon SES page, in the left side-bar, select Verified identities and add email addresses for verification the system sends an email to each address asking for verification by reply make sure DEFAULT_FROM_EMAIL in settings.py is a verified email address optionally, in your venv environment, test email works with: python manage.py shell >>> from django.core.mail import send_mail >>> send_mail('Subject', 'Message', 'one_of_your_verified_email_addresses_as_sender', ['one_of_your_verified_email_addresses_as_receiver'])","title":"Set up email"},{"location":"deploy_aws_walkthrough/#check-if-site-loads-3","text":"start celery in venv environment if not already running celery -A helios worker -l INFO restart all services sudo systemctl restart gunicorn.socket sudo systemctl daemon-reload sudo systemctl restart gunicorn.service sudo systemctl restart nginx in your browser go to https://your_domain_name","title":"Check if site loads - 3"},{"location":"deploy_aws_walkthrough/#daemonise-celery-to-start-automatically","text":"create /etc/systemd/system/celery.service sudo nano /etc/systemd/system/celery.service content of celery.service: [Unit] Description=Celery Service After=network.target [Service] User=ec2-user Group=ec2-user WorkingDirectory=/home/ec2-user/helios-server-master ExecStart=/home/ec2-user/helios-server-master/venv/bin/celery -A helios worker -l INFO [Install] WantedBy=multi-user.target then sudo systemctl daemon-reload # Get systemd to recognise celery.service sudo systemctl enable celery.service # Get celery.servce to run whenver rebooted sudo systemctl start celery.service # Start Celery","title":"Daemonise Celery to start automatically"},{"location":"deploy_aws_walkthrough/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"deploy_aws_walkthrough/#postgresql","text":"you may need to edit pg_hba.conf (located at /var/lib/pgsql/data/pg_hba.conf) for lines commencing host change the METHOD from ident to md5","title":"Postgresql"},{"location":"deploy_heroku/","text":"Heroku About Heroku Heroku is a subsidiary of salesforce.com. Its servers are hosted on Amazon's EC2 cloud-computing platform. When an app is deployed it runs in a container called a \u2018dyno\u2019. There is no direct access to its filesystem. There is more about dynos here . Heroku\u2019s pricing includes a free plan which is suitable for experimental purposes. It provides for 1 web process and 1 worker process (Celery in our case). The Heroku Postgres database is free within a limit of 10K rows. There is more about the free dyno here . Deployment There are options for deploying an app. One option is to link to a Github repository so that a push to Github triggers a build and deployment. Configuration There is one required configuration file - Procfile. This tells Heroku what to run when an app is deployed. I use the following for running one web server process and one Celery worker process: web: gunicorn wsgi worker: celery worker -A helios -l info Building and debugging Build logs can be viewed through Heroku\u2019s web interface, but for anything more than that it is important to become familiar with the Heroku CLI application. Heroku CLI can also run a psql shell for examining the database. Run this for a real-time display of logs generated on the Heroku site (if helios-heroku is the name of your app on Heroku): heroku logs --tail -a helios-heroku Helios requirements For tasks, Celery may be used and there are options for a broker (for example Redis). For sending email, an add-on, SendGrid , can be used. This is free up to 12,000 emails per month. Demo Code My wm-py3-django2-heroku branch: https://github.com/wrmack/helios-server/tree/wm-py3-django2-heroku Live https://helios-heroku.herokuapp.com","title":"Heroku"},{"location":"deploy_heroku/#heroku","text":"About Heroku Heroku is a subsidiary of salesforce.com. Its servers are hosted on Amazon's EC2 cloud-computing platform. When an app is deployed it runs in a container called a \u2018dyno\u2019. There is no direct access to its filesystem. There is more about dynos here . Heroku\u2019s pricing includes a free plan which is suitable for experimental purposes. It provides for 1 web process and 1 worker process (Celery in our case). The Heroku Postgres database is free within a limit of 10K rows. There is more about the free dyno here . Deployment There are options for deploying an app. One option is to link to a Github repository so that a push to Github triggers a build and deployment. Configuration There is one required configuration file - Procfile. This tells Heroku what to run when an app is deployed. I use the following for running one web server process and one Celery worker process: web: gunicorn wsgi worker: celery worker -A helios -l info Building and debugging Build logs can be viewed through Heroku\u2019s web interface, but for anything more than that it is important to become familiar with the Heroku CLI application. Heroku CLI can also run a psql shell for examining the database. Run this for a real-time display of logs generated on the Heroku site (if helios-heroku is the name of your app on Heroku): heroku logs --tail -a helios-heroku Helios requirements For tasks, Celery may be used and there are options for a broker (for example Redis). For sending email, an add-on, SendGrid , can be used. This is free up to 12,000 emails per month.","title":"Heroku"},{"location":"deploy_heroku/#demo","text":"Code My wm-py3-django2-heroku branch: https://github.com/wrmack/helios-server/tree/wm-py3-django2-heroku Live https://helios-heroku.herokuapp.com","title":"Demo"},{"location":"deploy_heroku_walkthrough/","text":"Deploying Helios to Heroku. Introduction This walk-through uses Heroku's free tier and uses free versions of add-ons for the database, process worker and email. It assumes: helios server is installed locally helios server is managed through git helios server has a remote repository on Github you have created an account on Heroku and are logged in you have downloaded and installed Heroku CLI which we will use for accessing the database. Caveat: this deployment has not been tested with a real election. It may help to get you started. Create a web app to run the helios server on Heroku by using Heroku dashboard go to https://dashboard.heroku.com go to New - Create new app give it a name and click Create app you should now be in the \"Deploy\" tab for \"Deployment method\" select Github for \"Connect to Github\" enter your repository name eg helios-server when Heroku has found your Github repository it will list it with a Connect button alongside click Connect your app name is referred to below as APPNAME - substitute the actual name you gave it Preparing helios server for deployment to Heroku Heroku requires a Procfile - create a file Procfile with the following content web: gunicorn wsgi:application -b 0.0.0.0:$PORT -w 8 worker: celery worker --app helios --events --beat --concurrency 1 you may go to \"Deploy by using the Heroku dashboard\" below at any time to examine error messages and comfirm whether you need to do the following. Secret environment variables (such as passwords) secrets need to be passed to Heroku as environment variables when you set up your Heroku app (so they are not visible in any files you have on Github) if you added a .env file and imported environ into settings.py for local development, remove them for deployment to Heroku go to the Settings tab on Heroku's dashboard page for your app and select Reveal Config Vars add your authentication credentials, eg in settings.py you might have: shell GOOGLE_CLIENT_ID = os.environ['GOOGLEID'] GOOGLE_CLIENT_SECRET = os.environ['GOOGLESECRET'] in which case you would add the keys GOOGLEID and GOOGLESECRET as 'config vars' and enter the appropriate values for each. Make sure that in Google console you enter the correct uris: ```shell Authorised JavaScript origins https://APPNAME.herokuapp.com Authorised redirect URIs https://APPNAME.herokuapp.com/auth/after/ ``` Settings other changes in settings.py : add the Heroku host to the ALLOWED_HOSTS array shell ALLOWED_HOSTS = ['APPNAME.herokuapp.com'] for URL_HOST add the Heroku url (it will automatically be used for the SECURE_URL_HOST) shell URL_HOST = get_from_env(\"URL_HOST\", \"https://APPNAME.herokuapp.com\").rstrip(\"/\") database settings should be: ```shell DATABASES = { 'default': { 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'helios', 'CONN_MAX_AGE': 600, }, } override if we have an env variable if get_from_env('DATABASE_URL', None): import dj_database_url DATABASES['default'] = dj_database_url.config(conn_max_age=600, ssl_require=True) DATABASES['default']['ENGINE'] = 'django.db.backends.postgresql_psycopg2' ``` Celery Celery requires a process worker - we will use CloudAMQP which is available as a Heroku add-on on the Heroku dashboard page for your app go to the Resources tab and select Find more add-ons under Add-on categories go to Messaging and Queuing select CloudAMQP under Plans & Pricing select Little Lemur (the free option) and Install CloudAMQP to provision the add-on for your app enter the name of your app and click Submit Order Form check it has been added by going to the Settings page - Config Vars should now include a key CLOUDAMQP_URL on the Resources page switch on celery worker if it is not already in settings.py add: CELERY_BROKER_URL = os.environ['CLOUDAMQP_URL'] BROKER_URL = os.environ['CLOUDAMQP_URL'] Dependencies Heroku loads all dependencies that are in requirements.txt if, in your local version of Helios, you loaded any dependency separately to what is in requirements.txt Heroku will not know about it, so put it in requirements.txt . Collectstatic by default, Heroku runs python manage.py collectstatic which we don't need so disable it: heroku config:set DISABLE_COLLECTSTATIC=1 --app APPNAME Deploy by using the Heroku dashboard commit all your changes and push to Github in Heroku dashboard for your app, in the Deploy tab, if you haven't set Enable Automatic Deploys , next to Manual deploy select the branch you want to deploy and click Deploy branch Heroku will attempt to install your helios server web app and it displays a log as it does this if it installs successfully Heroku will launch it click Open app at the top of the page to view your web page if launching fails, examine logs in a terminal with heroku logs --tail --app APPNAME there will be an error message because we have not set up the Postgreslq database yet. Database Heroku should have attached a Postgresql database to your app and created the 'helios' database in line with your database settings in settings.py create a Heroku shell and populate the 'helios' database heroku run bash --app APPNAME ~ $ python manage.py makemigrations ~ $ python manage.py migrate ~ $ exit check database tables have been created: heroku pg:psql --app APPNAME APPNAME::DATABASE=> \\d APPNAME::DATABASE=> \\q (optional) open your app again, or refresh it if it is already open in your browser - it should run this time, but you should be able to create an election but cannot yet send emails. Email we need to set up an add-on that will take care of sending emails to voters - Heroku has a couple of third party add-ons that do this on the Heroku dashboard page for your app go to the Resources tab and select Find more add-ons under Add-on categories go to Email/SMS select Mailgun (or Sendgrid, Trustifi, CloudMailin) under Plans & Pricing select Starter (the free option) and Install Mailgun to provision the add-on for your app enter the name of your app and click Submit Order Form check it has been added by going to the Settings page - Config Vars should now include a number of keys relating to Mailgun your email settings in settings.py should be: EMAIL_HOST = os.environ['MAILGUN_SMTP_SERVER'] EMAIL_HOST_USER = os.environ['MAILGUN_SMTP_LOGIN'] EMAIL_HOST_PASSWORD = os.environ['MAILGUN_SMTP_PASSWORD'] EMAIL_PORT = 587 EMAIL_USE_TLS = True Mailgun places starting users in sandbox accounts which require email recipients to verify their email addresses (you can send an email to yourself without verification) to add recipients, on the Heroku dashboard page for your app go to the Resources tab and click on the Mailgun add-on which will take you to your account on Mailgun on the Mailgun dashbord, select the sandbox account on the right there is a side-box where it is possible to add recipients after a recipient is added, a confirmation email is automatically sent to the recipient who has to click an \"I agree\" button following the changes to settings.py, commit and push to Github go to the Heroku dashboard and, under Deploy, do a manual deploy if you have not set it up for automatic deploy you should now be able to send emails to yourself and verified recipients from within Helios","title":"Heroku walk-through"},{"location":"deploy_heroku_walkthrough/#introduction","text":"This walk-through uses Heroku's free tier and uses free versions of add-ons for the database, process worker and email. It assumes: helios server is installed locally helios server is managed through git helios server has a remote repository on Github you have created an account on Heroku and are logged in you have downloaded and installed Heroku CLI which we will use for accessing the database. Caveat: this deployment has not been tested with a real election. It may help to get you started.","title":"Introduction"},{"location":"deploy_heroku_walkthrough/#create-a-web-app-to-run-the-helios-server-on-heroku-by-using-heroku-dashboard","text":"go to https://dashboard.heroku.com go to New - Create new app give it a name and click Create app you should now be in the \"Deploy\" tab for \"Deployment method\" select Github for \"Connect to Github\" enter your repository name eg helios-server when Heroku has found your Github repository it will list it with a Connect button alongside click Connect your app name is referred to below as APPNAME - substitute the actual name you gave it","title":"Create a web app to run the helios server on Heroku by using Heroku dashboard"},{"location":"deploy_heroku_walkthrough/#preparing-helios-server-for-deployment-to-heroku","text":"Heroku requires a Procfile - create a file Procfile with the following content web: gunicorn wsgi:application -b 0.0.0.0:$PORT -w 8 worker: celery worker --app helios --events --beat --concurrency 1 you may go to \"Deploy by using the Heroku dashboard\" below at any time to examine error messages and comfirm whether you need to do the following. Secret environment variables (such as passwords) secrets need to be passed to Heroku as environment variables when you set up your Heroku app (so they are not visible in any files you have on Github) if you added a .env file and imported environ into settings.py for local development, remove them for deployment to Heroku go to the Settings tab on Heroku's dashboard page for your app and select Reveal Config Vars add your authentication credentials, eg in settings.py you might have: shell GOOGLE_CLIENT_ID = os.environ['GOOGLEID'] GOOGLE_CLIENT_SECRET = os.environ['GOOGLESECRET'] in which case you would add the keys GOOGLEID and GOOGLESECRET as 'config vars' and enter the appropriate values for each. Make sure that in Google console you enter the correct uris: ```shell","title":"Preparing helios server for deployment to Heroku"},{"location":"deploy_heroku_walkthrough/#authorised-javascript-origins","text":"https://APPNAME.herokuapp.com","title":"Authorised JavaScript origins"},{"location":"deploy_heroku_walkthrough/#authorised-redirect-uris","text":"https://APPNAME.herokuapp.com/auth/after/ ``` Settings other changes in settings.py : add the Heroku host to the ALLOWED_HOSTS array shell ALLOWED_HOSTS = ['APPNAME.herokuapp.com'] for URL_HOST add the Heroku url (it will automatically be used for the SECURE_URL_HOST) shell URL_HOST = get_from_env(\"URL_HOST\", \"https://APPNAME.herokuapp.com\").rstrip(\"/\") database settings should be: ```shell DATABASES = { 'default': { 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'helios', 'CONN_MAX_AGE': 600, }, }","title":"Authorised redirect URIs"},{"location":"deploy_heroku_walkthrough/#override-if-we-have-an-env-variable","text":"if get_from_env('DATABASE_URL', None): import dj_database_url DATABASES['default'] = dj_database_url.config(conn_max_age=600, ssl_require=True) DATABASES['default']['ENGINE'] = 'django.db.backends.postgresql_psycopg2' ``` Celery Celery requires a process worker - we will use CloudAMQP which is available as a Heroku add-on on the Heroku dashboard page for your app go to the Resources tab and select Find more add-ons under Add-on categories go to Messaging and Queuing select CloudAMQP under Plans & Pricing select Little Lemur (the free option) and Install CloudAMQP to provision the add-on for your app enter the name of your app and click Submit Order Form check it has been added by going to the Settings page - Config Vars should now include a key CLOUDAMQP_URL on the Resources page switch on celery worker if it is not already in settings.py add: CELERY_BROKER_URL = os.environ['CLOUDAMQP_URL'] BROKER_URL = os.environ['CLOUDAMQP_URL'] Dependencies Heroku loads all dependencies that are in requirements.txt if, in your local version of Helios, you loaded any dependency separately to what is in requirements.txt Heroku will not know about it, so put it in requirements.txt . Collectstatic by default, Heroku runs python manage.py collectstatic which we don't need so disable it: heroku config:set DISABLE_COLLECTSTATIC=1 --app APPNAME","title":"override if we have an env variable"},{"location":"deploy_heroku_walkthrough/#deploy-by-using-the-heroku-dashboard","text":"commit all your changes and push to Github in Heroku dashboard for your app, in the Deploy tab, if you haven't set Enable Automatic Deploys , next to Manual deploy select the branch you want to deploy and click Deploy branch Heroku will attempt to install your helios server web app and it displays a log as it does this if it installs successfully Heroku will launch it click Open app at the top of the page to view your web page if launching fails, examine logs in a terminal with heroku logs --tail --app APPNAME there will be an error message because we have not set up the Postgreslq database yet. Database Heroku should have attached a Postgresql database to your app and created the 'helios' database in line with your database settings in settings.py create a Heroku shell and populate the 'helios' database heroku run bash --app APPNAME ~ $ python manage.py makemigrations ~ $ python manage.py migrate ~ $ exit check database tables have been created: heroku pg:psql --app APPNAME APPNAME::DATABASE=> \\d APPNAME::DATABASE=> \\q (optional) open your app again, or refresh it if it is already open in your browser - it should run this time, but you should be able to create an election but cannot yet send emails.","title":"Deploy by using the Heroku dashboard"},{"location":"deploy_heroku_walkthrough/#email","text":"we need to set up an add-on that will take care of sending emails to voters - Heroku has a couple of third party add-ons that do this on the Heroku dashboard page for your app go to the Resources tab and select Find more add-ons under Add-on categories go to Email/SMS select Mailgun (or Sendgrid, Trustifi, CloudMailin) under Plans & Pricing select Starter (the free option) and Install Mailgun to provision the add-on for your app enter the name of your app and click Submit Order Form check it has been added by going to the Settings page - Config Vars should now include a number of keys relating to Mailgun your email settings in settings.py should be: EMAIL_HOST = os.environ['MAILGUN_SMTP_SERVER'] EMAIL_HOST_USER = os.environ['MAILGUN_SMTP_LOGIN'] EMAIL_HOST_PASSWORD = os.environ['MAILGUN_SMTP_PASSWORD'] EMAIL_PORT = 587 EMAIL_USE_TLS = True Mailgun places starting users in sandbox accounts which require email recipients to verify their email addresses (you can send an email to yourself without verification) to add recipients, on the Heroku dashboard page for your app go to the Resources tab and click on the Mailgun add-on which will take you to your account on Mailgun on the Mailgun dashbord, select the sandbox account on the right there is a side-box where it is possible to add recipients after a recipient is added, a confirmation email is automatically sent to the recipient who has to click an \"I agree\" button following the changes to settings.py, commit and push to Github go to the Heroku dashboard and, under Deploy, do a manual deploy if you have not set it up for automatic deploy you should now be able to send emails to yourself and verified recipients from within Helios","title":"Email"},{"location":"faq_faq1/","text":"[To be completed] For voters How does online voting with Helios Voting work? This is the explanation Do I need special internet skills or software to vote with Helios Voting? No. Voting takes place using your web browser. Helios has been tested with Safari, Chrome, Firefox, (Edge?, Internet Explorer?, Opera?). It should also work using the browser on your smart phone. It is always best to have your browser updated to the most recent version. How can I be assured my vote is counted? Explanation For election admins About security","title":"Faq faq1"},{"location":"faq_faq1/#for-voters","text":"How does online voting with Helios Voting work? This is the explanation Do I need special internet skills or software to vote with Helios Voting? No. Voting takes place using your web browser. Helios has been tested with Safari, Chrome, Firefox, (Edge?, Internet Explorer?, Opera?). It should also work using the browser on your smart phone. It is always best to have your browser updated to the most recent version. How can I be assured my vote is counted? Explanation","title":"For voters"},{"location":"faq_faq1/#for-election-admins","text":"","title":"For election admins"},{"location":"faq_faq1/#about-security","text":"","title":"About security"},{"location":"how_overview/","text":"Overview This section on \"How it works\" is based on Ben Adida's documentation, my own experience with trying it out and my reading of the academic literature. My aim is for it to be helpful for the general user (as opposed to a cryptographic expert who should consult the academic literature instead). Nevertheless, the cryptographic aspects are key security features and I will do my best to explain their implementation in lay-person terms. The following is a very brief summary of the key screens: pre-voting phase: the election setup voting phase: the voting booth post-voting phase: election results. Pre-voting phase: the election setup The election administrator: visits the election site (eg https://vote.heliosvoting.org ) logs in sets up the election. If the administrator sets up the election for only those voters whose names are uploaded, the server sends an email to each voter. The email contains the election url, fingerprint and the log-in id and password of the voter. What the administrator sees What the administrator sees after logging in Voting phase: the voting booth The voter: visits the link in the emaiil is presented with the voting booth selects their choices submits their ballot to the server. The email the voter receives contains: Election URL: https://helios.wrmack.com/helios/e/Election_three/vote Election Fingerprint: stRyU7w/Ephk/ioLSXAGk5lHIwd+7KJ8lZa3lO2fD1I Your voter ID: ******** Your password: ******** What the voter sees after clicking the election url Post-voting phase: the election results Once voting is over, the election administrator causes the votes to be tallied. The election administrator can send an email to each voter giving them a link to this screen:","title":"Overview"},{"location":"how_overview/#overview","text":"This section on \"How it works\" is based on Ben Adida's documentation, my own experience with trying it out and my reading of the academic literature. My aim is for it to be helpful for the general user (as opposed to a cryptographic expert who should consult the academic literature instead). Nevertheless, the cryptographic aspects are key security features and I will do my best to explain their implementation in lay-person terms. The following is a very brief summary of the key screens: pre-voting phase: the election setup voting phase: the voting booth post-voting phase: election results.","title":"Overview"},{"location":"how_overview/#pre-voting-phase-the-election-setup","text":"The election administrator: visits the election site (eg https://vote.heliosvoting.org ) logs in sets up the election. If the administrator sets up the election for only those voters whose names are uploaded, the server sends an email to each voter. The email contains the election url, fingerprint and the log-in id and password of the voter.","title":"Pre-voting phase: the election setup"},{"location":"how_overview/#what-the-administrator-sees","text":"","title":"What the administrator sees"},{"location":"how_overview/#what-the-administrator-sees-after-logging-in","text":"","title":"What the administrator sees after logging in"},{"location":"how_overview/#voting-phase-the-voting-booth","text":"The voter: visits the link in the emaiil is presented with the voting booth selects their choices submits their ballot to the server. The email the voter receives contains: Election URL: https://helios.wrmack.com/helios/e/Election_three/vote Election Fingerprint: stRyU7w/Ephk/ioLSXAGk5lHIwd+7KJ8lZa3lO2fD1I Your voter ID: ******** Your password: ********","title":"Voting phase: the voting booth"},{"location":"how_overview/#what-the-voter-sees-after-clicking-the-election-url","text":"","title":"What the voter sees after clicking the election url"},{"location":"how_overview/#post-voting-phase-the-election-results","text":"Once voting is over, the election administrator causes the votes to be tallied. The election administrator can send an email to each voter giving them a link to this screen:","title":"Post-voting phase: the election results"},{"location":"how_security/","text":"Security features Helios has been the subject of many academic papers written about the security of online voting systems. You can find some of these papers in References - Academic papers .","title":"Security features"},{"location":"how_security/#security-features","text":"Helios has been the subject of many academic papers written about the security of online voting systems. You can find some of these papers in References - Academic papers .","title":"Security features"},{"location":"how_simple/","text":"Simple encryption model A simple encryption model for conducting an election might go something like this: Election administrator sets up the election and creates a public - private key pair. Election administrator publishes the public key. Each voter encrypts their vote with the election public key and sends the encrypted vote to the election administrator. When the election closes, the administrator decrypts all votes using the private key and tallies the votes. The election administrator publishes the result. Communication of the vote would likely be over TLS and so it would be encrypted in transmission anyway. The only security added by this model is that when it is received and stored on the server it is encrypted. The model has other problems. Problems the election administrator is able to decrypt votes and may be able to determine how a particular voter voted (ballot privacy breached) the voter does not know whether their vote was correctly encrypted (cast-as-intended cannot be checked) the voter is not able to verify that the election outcome correctly represents their own vote (recorded-as-cast and tallied-as-recorded cannot be checked)","title":"Simple encryption"},{"location":"how_simple/#simple-encryption-model","text":"A simple encryption model for conducting an election might go something like this: Election administrator sets up the election and creates a public - private key pair. Election administrator publishes the public key. Each voter encrypts their vote with the election public key and sends the encrypted vote to the election administrator. When the election closes, the administrator decrypts all votes using the private key and tallies the votes. The election administrator publishes the result. Communication of the vote would likely be over TLS and so it would be encrypted in transmission anyway. The only security added by this model is that when it is received and stored on the server it is encrypted. The model has other problems.","title":"Simple encryption model"},{"location":"how_simple/#problems","text":"the election administrator is able to decrypt votes and may be able to determine how a particular voter voted (ballot privacy breached) the voter does not know whether their vote was correctly encrypted (cast-as-intended cannot be checked) the voter is not able to verify that the election outcome correctly represents their own vote (recorded-as-cast and tallied-as-recorded cannot be checked)","title":"Problems"},{"location":"inst_auth/","text":"Authentication systems Google To get Google Auth working: ** go to https://console.developers.google.com ** create an application ** set up oauth2 credentials as a web application, with your origin, e.g. https://myhelios.example.com , and your auth callback, which, based on our example, is https://myhelios.example.com/auth/after/ ** still in the developer console, enable the Google+ API. ** set the GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET configuration variables accordingly.","title":"Setup authentication"},{"location":"inst_auth/#authentication-systems","text":"","title":"Authentication systems"},{"location":"inst_auth/#google","text":"To get Google Auth working: ** go to https://console.developers.google.com ** create an application ** set up oauth2 credentials as a web application, with your origin, e.g. https://myhelios.example.com , and your auth callback, which, based on our example, is https://myhelios.example.com/auth/after/ ** still in the developer console, enable the Google+ API. ** set the GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET configuration variables accordingly.","title":"Google"},{"location":"inst_dev/","text":"Local development Flow for starting helios Start rabbitmq In a new terminal: /usr/local/sbin/rabbitmq-server Start celery In a new terminal, in helios-server root folder: source venv/bin/activate celery -A helios worker -l info Start helios (In settings.py PRODUCTION = False to tell Django to use the development server) In a new terminal: source venv/bin/activate python manage.py runserver View in browser In browser go to: http://localhost:8000 Visual Studio Code If using Visual Studio Code, to launch helios using the debugger add this to \"configurations\" in launch.json: { \"name\": \"Python: Django\", \"type\": \"python\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/manage.py\", \"args\": [ \"runserver\", \"--noreload\" ], \"django\": true, \"justMyCode\": false } Set \"justMyCode\" to True for Call Stack to show your own code only.","title":"Local development"},{"location":"inst_dev/#local-development","text":"","title":"Local development"},{"location":"inst_dev/#flow-for-starting-helios","text":"","title":"Flow for starting helios"},{"location":"inst_dev/#start-rabbitmq","text":"In a new terminal: /usr/local/sbin/rabbitmq-server","title":"Start rabbitmq"},{"location":"inst_dev/#start-celery","text":"In a new terminal, in helios-server root folder: source venv/bin/activate celery -A helios worker -l info","title":"Start celery"},{"location":"inst_dev/#start-helios","text":"(In settings.py PRODUCTION = False to tell Django to use the development server) In a new terminal: source venv/bin/activate python manage.py runserver","title":"Start helios"},{"location":"inst_dev/#view-in-browser","text":"In browser go to: http://localhost:8000","title":"View in browser"},{"location":"inst_dev/#visual-studio-code","text":"If using Visual Studio Code, to launch helios using the debugger add this to \"configurations\" in launch.json: { \"name\": \"Python: Django\", \"type\": \"python\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/manage.py\", \"args\": [ \"runserver\", \"--noreload\" ], \"django\": true, \"justMyCode\": false } Set \"justMyCode\" to True for Call Stack to show your own code only.","title":"Visual Studio Code"},{"location":"inst_django/","text":"Django installation settings.py Customise the following in settings.py: ADMINS HOSTS DATABASES TIME, LANGUAGE HELP_EMAIL_ADDRESS Authentication systems GOOGLE_CLIENT_ID GOOGLE_CLIENT_SECRET Email settings collectstatic What it does: collects all static files that are located in the static folders of the installed apps and stores them in the folder that is set as STATIC_ROOT (currently the /static folder). When to use: the STATIC_ROOT folder is empty or you have changed the static files in one of the installed app's static folders How to use: to completely refresh the files held in STATIC_ROOT , empty it first in terminal: python manage.py collectstatic makemigrations What it does: Migrations are Django\u2019s way of propagating changes you make to your models (adding a field, deleting a model, etc.) into your database schema. makemigrations creates new migrations based on the changes you have made to your models. When to use: After you make a change to your models. How to use: in a terminal: python manage.py makemigrations reset database What it does: deletes your helios database, creates a new helios database and migrates your models to the database. When to use: After you have run makemigrations How to use: ./reset.sh","title":"Prepare Django"},{"location":"inst_django/#django-installation","text":"","title":"Django installation"},{"location":"inst_django/#settingspy","text":"Customise the following in settings.py: ADMINS HOSTS DATABASES TIME, LANGUAGE HELP_EMAIL_ADDRESS Authentication systems GOOGLE_CLIENT_ID GOOGLE_CLIENT_SECRET Email settings","title":"settings.py"},{"location":"inst_django/#collectstatic","text":"What it does: collects all static files that are located in the static folders of the installed apps and stores them in the folder that is set as STATIC_ROOT (currently the /static folder). When to use: the STATIC_ROOT folder is empty or you have changed the static files in one of the installed app's static folders How to use: to completely refresh the files held in STATIC_ROOT , empty it first in terminal: python manage.py collectstatic","title":"collectstatic"},{"location":"inst_django/#makemigrations","text":"What it does: Migrations are Django\u2019s way of propagating changes you make to your models (adding a field, deleting a model, etc.) into your database schema. makemigrations creates new migrations based on the changes you have made to your models. When to use: After you make a change to your models. How to use: in a terminal: python manage.py makemigrations","title":"makemigrations"},{"location":"inst_django/#reset-database","text":"What it does: deletes your helios database, creates a new helios database and migrates your models to the database. When to use: After you have run makemigrations How to use: ./reset.sh","title":"reset database"},{"location":"inst_env/","text":"Environment essentials for local development If not already installed: install Python 3 install PostgreSQL install Celery to run asynchronous tasks install RabbitMQ as the message broker recommended by Celery install pip , the python package manager then: download helios-server cd into the helios-server directory create a virtual environment: python3 -m venv venv activate the virtual environment: source venv/bin/activate install dependency requirements: python3 -m pip install -r requirements.txt","title":"Environment essentials"},{"location":"inst_env/#environment-essentials-for-local-development","text":"If not already installed: install Python 3 install PostgreSQL install Celery to run asynchronous tasks install RabbitMQ as the message broker recommended by Celery install pip , the python package manager then: download helios-server cd into the helios-server directory create a virtual environment: python3 -m venv venv activate the virtual environment: source venv/bin/activate install dependency requirements: python3 -m pip install -r requirements.txt","title":"Environment essentials for local development"},{"location":"inst_virtualbox/","text":"Walk-through of installing Ben Adida's Helios Election System on Ubuntu 20.10 (optional) install VSCode or VSCodium for editing code, having an integrated terminal check python3 is installed with Ubuntu and, if not, install it python3 --version install pip3 sudo apt install python3-pip install python3-venv sudo apt install python3-venv install Postgresql sudo apt-get update sudo apt install postgresql sudo systemctl start postgresql@12-main (prompted by the installation) sudo -i -u postgres (become the postgres user) psql postgres (connect to the postgres database) CREATE USER [your login name] WITH SUPERUSER; (create Helios database user) CREATE DATABASE helios WITH OWNER [your login name]; (create Helios database) \\q (quit psql) exit (logout as the postgres user) psql helios (connect to the new helios database) \\l (list databases - check helios is there) \\q install RabbitMQ sudo apt install rabbitmq-server setup Google OAuth authentication in a browser go to: https://console.developers.google.com/apis (you should have a Google account) select Credentials Create a project and give it a name (eg Helios) then CREATE CREDENTIALS OAuth client ID CONFIGURE CONSENT SCREEN - select External then CREATE Just complete the required fields (App name, User support email and Developer contact email) then SAVE AND CONTINUE Under Scopes and Optional info add nothing just SAVE AND CONTINUE then on Summary page BACK TO DASHBOARD select Credentials then CREATE CREDENTIALS Application type is Web application Name is your choice (eg Helios) Authorised Javascript origins: http://localhost:8000 Authorised redirect URIs: http://localhost:8000/auth/after/ CREATE copy Client ID and Client secret for using in Helios Select Dashboard then ENABLE APIS AND SERVICES Select Google People API and ENABLE download Helios code: in a browser go to https://github.com/benadida/helios-server under Code choose Download ZIP once downloaded double-click the Zip arhive to unarchive it and move all to a project folder of your choice for working on (ie move code out of the Downloads folder) prepare helios cd to your project folder create a virtual environment python3 -m venv my-venv activate the virtual environment: source my-venv/bin/activate install all dependencies in requirements.txt: python3 -m pip install wheel (in response to an error message) sudo apt install libpq-dev (required for installation of psycopg2) (in requirements.txt I upgraded celery to 5.0.0 and replaced pycrypto with pycryptodome for compatability with python 3.8) python3 -m pip install -r requirements.txt safe storage of secrets optional but if your code is kept on Github this is preferable to hard-coding your Google credentials into settings.py python3 -m pip install django-environ create an .env file with stored secrets shell DBPWD=xxxx GOOGLESECRET=xxxx GOOGLEID=xxxx in settings.py insert following after import os ```shell import environ # Read in secrets from .env file env = environ.Env() environ.Env.read_env() DBPWD = env('DBPWD') GOOGLESECRET = env('GOOGLESECRET') GOOGLEID = env('GOOGLEID') - in `settings.py`: shell # google GOOGLE_CLIENT_ID = get_from_env('GOOGLE_CLIENT_ID', GOOGLEID) GOOGLE_CLIENT_SECRET = get_from_env('GOOGLE_CLIENT_SECRET', GOOGLESECRET) `` - add .env to .gitignore so it is not uploaded to Github - in a separate terminal start celery - cd to your helios project - source my-venv/bin/activate - celery -A helios worker -l INFO - back at first terminal, run helios - python3 manage.py makemigrations - ./reset.sh - python3 manage.py runserver - in a browser go to localhost:8000 (alternatively go to 127.0.0.1:8000` but change references to localhost in settings.py to 127.0.0.1 and in Google OAuth authentication replace localhost with 127.0.0.1)","title":"Walk-through with Ubuntu"},{"location":"inst_virtualbox/#walk-through-of-installing-ben-adidas-helios-election-system-on-ubuntu-2010","text":"(optional) install VSCode or VSCodium for editing code, having an integrated terminal check python3 is installed with Ubuntu and, if not, install it python3 --version install pip3 sudo apt install python3-pip install python3-venv sudo apt install python3-venv install Postgresql sudo apt-get update sudo apt install postgresql sudo systemctl start postgresql@12-main (prompted by the installation) sudo -i -u postgres (become the postgres user) psql postgres (connect to the postgres database) CREATE USER [your login name] WITH SUPERUSER; (create Helios database user) CREATE DATABASE helios WITH OWNER [your login name]; (create Helios database) \\q (quit psql) exit (logout as the postgres user) psql helios (connect to the new helios database) \\l (list databases - check helios is there) \\q install RabbitMQ sudo apt install rabbitmq-server setup Google OAuth authentication in a browser go to: https://console.developers.google.com/apis (you should have a Google account) select Credentials Create a project and give it a name (eg Helios) then CREATE CREDENTIALS OAuth client ID CONFIGURE CONSENT SCREEN - select External then CREATE Just complete the required fields (App name, User support email and Developer contact email) then SAVE AND CONTINUE Under Scopes and Optional info add nothing just SAVE AND CONTINUE then on Summary page BACK TO DASHBOARD select Credentials then CREATE CREDENTIALS Application type is Web application Name is your choice (eg Helios) Authorised Javascript origins: http://localhost:8000 Authorised redirect URIs: http://localhost:8000/auth/after/ CREATE copy Client ID and Client secret for using in Helios Select Dashboard then ENABLE APIS AND SERVICES Select Google People API and ENABLE download Helios code: in a browser go to https://github.com/benadida/helios-server under Code choose Download ZIP once downloaded double-click the Zip arhive to unarchive it and move all to a project folder of your choice for working on (ie move code out of the Downloads folder) prepare helios cd to your project folder create a virtual environment python3 -m venv my-venv activate the virtual environment: source my-venv/bin/activate install all dependencies in requirements.txt: python3 -m pip install wheel (in response to an error message) sudo apt install libpq-dev (required for installation of psycopg2) (in requirements.txt I upgraded celery to 5.0.0 and replaced pycrypto with pycryptodome for compatability with python 3.8) python3 -m pip install -r requirements.txt safe storage of secrets optional but if your code is kept on Github this is preferable to hard-coding your Google credentials into settings.py python3 -m pip install django-environ create an .env file with stored secrets shell DBPWD=xxxx GOOGLESECRET=xxxx GOOGLEID=xxxx in settings.py insert following after import os ```shell import environ # Read in secrets from .env file env = environ.Env() environ.Env.read_env() DBPWD = env('DBPWD') GOOGLESECRET = env('GOOGLESECRET') GOOGLEID = env('GOOGLEID') - in `settings.py`: shell # google GOOGLE_CLIENT_ID = get_from_env('GOOGLE_CLIENT_ID', GOOGLEID) GOOGLE_CLIENT_SECRET = get_from_env('GOOGLE_CLIENT_SECRET', GOOGLESECRET) `` - add .env to .gitignore so it is not uploaded to Github - in a separate terminal start celery - cd to your helios project - source my-venv/bin/activate - celery -A helios worker -l INFO - back at first terminal, run helios - python3 manage.py makemigrations - ./reset.sh - python3 manage.py runserver - in a browser go to localhost:8000 (alternatively go to 127.0.0.1:8000` but change references to localhost in settings.py to 127.0.0.1 and in Google OAuth authentication replace localhost with 127.0.0.1)","title":"Walk-through of installing Ben Adida's Helios Election System on Ubuntu 20.10"},{"location":"privacy/","text":"I use Umami , an open source application, to count visits to pages. This records which pages were viewed, a user's country, referrers, the operating systems and browsers of users. It does not record any personal information. It does not use this information for any other purpose than providing a dashboard displaying these statistics.","title":"Privacy"},{"location":"ref_components/","text":"Components Django installed apps HelioSolid is an application which has been deployed to a server. The application uses the Django web framework for serving pages and storing data. The Django application comprises three \"installed apps\": server_ui helios_auth helios server_ui The server_ui app presents the initial page with: helios The helios app presents all pages relating to an election. It holds the list of registered voters for an election. It stores all encrypted ballots once they have been retrieved from voter's pods. It tallys the vote once all ballots have been retrieved. helios_auth The helios_auth app handles authentication. Voting booth Once an admin has uploaded a csv file of voters the admin will cause an email to be sent to voters which contains their login name and password and an url to the election. When a voter clicks on the url the server presents the voter with the voting booth which is updated by javascript as the voter works through their voting selections. The vote is encrypted in the browser. There are no further network requests to the server until the voter decides to cast their vote. The voting booth is decoupled from the server.","title":"Components"},{"location":"ref_components/#components","text":"","title":"Components"},{"location":"ref_components/#django-installed-apps","text":"HelioSolid is an application which has been deployed to a server. The application uses the Django web framework for serving pages and storing data. The Django application comprises three \"installed apps\": server_ui helios_auth helios","title":"Django installed apps"},{"location":"ref_components/#server_ui","text":"The server_ui app presents the initial page with:","title":"server_ui"},{"location":"ref_components/#helios","text":"The helios app presents all pages relating to an election. It holds the list of registered voters for an election. It stores all encrypted ballots once they have been retrieved from voter's pods. It tallys the vote once all ballots have been retrieved.","title":"helios"},{"location":"ref_components/#helios_auth","text":"The helios_auth app handles authentication.","title":"helios_auth"},{"location":"ref_components/#voting-booth","text":"Once an admin has uploaded a csv file of voters the admin will cause an email to be sent to voters which contains their login name and password and an url to the election. When a voter clicks on the url the server presents the voter with the voting booth which is updated by javascript as the voter works through their voting selections. The vote is encrypted in the browser. There are no further network requests to the server until the voter decides to cast their vote. The voting booth is decoupled from the server.","title":"Voting booth"},{"location":"ref_literature/","text":"Academic papers assessing Helios 2008 Helios: Web-based Open-Audit Voting Ben Adida Presentation of an early version of helios to the 17 th USENIX Security Symposium, 2008 2009 Electing a University President using Open-Audit Voting: Analysis of real-world use of Helios Ben Adida, Olivier Pereira, Olivier de Marneffe, Jean-Jacques Quisquater Presentation to Electronic Voting Technology Workshop/Workshop on Trustworthy Elections, 2009 Usability Study of the Open Audit Voting System Helios Janna-Lynn Weber, Urs Hengartner 2010 Exploiting the Client Vulnerabilities in Internet E-voting Systems: Hacking Helios 2.0 as an Example Saghar Estehghari, Yvo Desmedt The Helios e-Voting Demo for the IACR Stuart Haber, Josh Benaloh, Shai Halevi 2011 Running mixnet-based elections with Helios Philippe Bulens, Damien Giry, Olivier Pereira Presentation to Electronic Voting Technology Workshop/Workshop on Trustworthy Elections, 2011 User study of the improved Helios voting system interfaces Fatih Karayumak, Michaela Kauer, M. Maina Olembo, Tobias Volk, Melanie Volkamer Adapting Helios for provable ballot privacy David Bernhard, V\u00e9ronique Cortier, Olivier Pereira, Ben Smyth, Bogdan Warinschi Usability Analysis of Helios - An Open Source Verifiable Remote Electronic Voting System Fatih Karayumak, Maina M. Olembo, Michaela Kauer and Melanie Volkamer 2013 A generic construction for voting correctness at minimum cost - Application to Helios V\u00e9ronique Cortier, David Galindo, St\u00e9phane Glondu, Malika Izabach\u00e8ne Attacking and fixing Helios: An analysis of ballot secrecy V\u00e9ronique Cortier and Ben Smyth Distributed ElGamal \u00e0 la Pedersen - Application to Helios V\u00e9ronique Cortier, David Galindo, St\u00e9phane Glondu, Malika Izabache\u0300ne 2014 Usability of Voter Verifiable, End-to-end Voting Systems: Baseline Data for Helios, Pre\u0302t a\u0300 Voter, and Scantegrity II Claudia Z. Acemyan, Philip Kortum, Michael D. Byrne, Dan S. Wallach Helios Verification: To Alleviate, or to Nominate: Is That The Question, Or Shall We Have Both? Stephan Neumann, M. Maina Olembo, Karen Renaud, and Melanie Volkamer A Security Analysis of the Helios Voting Protocol and Application to the Norwegian County Election Kristine Salamonsen (Masters thesis) 2015 Extending Helios Towards Private Eligibility Verifiability Oksana Kulyk, Vanessa Teague, and Melanie Volkamer E-Voting and Identity: 5 th International Conference, VoteID 2015 Election Verifiability for Helios under Weaker Trust Assumptions Ve\u0301ronique Cortier, David Galindo, Ste\u0301phane Glondu and Malika Izabache\u0300ne 2016 Internet voting with Helios Olivier Pereira Chapter in: Feng Hao and Peter Y. A. Ryan (Eds.), Real-World Electronic Voting: Design, Analysis and Deployment , 2016 The Cloudier Side of Cryptographic End-to-end Verifiable Voting: A Security Analysis of Helios Nicholas Chang-Fong, Aleksander Essex Proceedings of the 32 nd Annual Conference on Computer Security Applications, 2016 Implementation-level Analysis of the JavaScript Helios Voting Client Michael Backes, Christian Hammer, David Pfaff, Malte Skoruppa Proceedings of the 31 st Annual ACM Symposium on Applied Computing, 2016 How not to Prove Yourself: Pitfalls of the Fiat-Shamir Heuristic and Applications to Helios David Bernhard, Olivier Pereira, and Bogdan Warinschi Adapting Helios for provable ballot privacy David Bernhard, V\u00e9ronique Cortier, Olivier Pereira, Ben Smyth, Bogdan Warinschi Introducing Proxy Voting to Helios Oksana Kulyk, Karola Marky, Stephan Neumann, Melanie Volkamer Apollo \u2013 End-to-end Verifiable Internet Voting with Recovery from Vote Manipulation Dawid Gawel, Maciej Kosarzecki, Poorvi L. Vora, Hua Wu, and Filip Zag\u00f3rski Cryptographic Voting \u2014 A Gentle Introduction David Bernhard, Bogdan Warinschi 2017 Machine-Checked Proofs of Privacy for Electronic Voting Protocols V\u00e9ronique Cortier, Constantin C\u0103t\u0103lin Dr\u0103gan, Fran\u00e7ois Dupressoir, Benedikt Schmidt, Pierre-Yves Strub, Bogdan Warinschi Security Proofs for Participation Privacy, Receipt-Freeness, Ballot Privacy for the Helios Voting Scheme David Bernhard, Oksana Kulyk, Melanie Volkamer 2018 E-voting system evaluation based on the Council of Europe recommendations: Helios Voting Luis Panizo, Mila Gasco\u0301, David Y. Marcos del Blanco, Jose\u0301 A. Hermida, Jordi Barrat and He\u0301ctor Ala\u0301iz IEEE Transactions on Emerging Topics in Computing, 2018 Comparative Usability Evaluation of Cast-as-Intended Verification Approaches in Internet Voting Karola Marky, Oksana Kulyk, Melanie Volkamer Ballot secrecy: Security definition, sufficient conditions, and analysis of Helios Ben Smyth Exploiting re-voting in the Helios election system Maxime Meyera, Ben Smyth Verifiability of Helios Mixnet Ben Smyth A foundation for secret, verifiable elections Ben Smyth 2019 A protocolized, comparative study of Helios Voting and Scytl/iVote David Y Marcos del Blanco and Mila Gasco\u0301 Sixth International Conference on eDemocracy & eGovernment (ICEDEG), 2019 A Framework for I-Voting based on Helios and Public-Key Certificates Noor Hamad Abid, Sufyan T. Faraj Al-Janabi A simple alternative to Benaloh challenge for the cast-as-intended property in Helios/Belenios Ve\u0301ronique Cortier, Jannik Dreier, Pierrick Gaudry, Mathieu Turuani 2020 Fifty Shades of Ballot Privacy: Privacy against a Malicious Board V\u00e9ronique Cortier, Joseph Lallemand, Bogdan Warinschi The Secure I-Voting System Helios++ Noor Hamad Abid, Sufyan T. Faraj Al-Janabi Verifiable Public Credentials for Stronger End-to-End Verifiability Sevdenur Baloglu 2021 Helios: Attacks and Formal Models for Verifiability Panagiotis Grontas Election Verifiability Revisited: Automated Security Proofs and Attacks on Helios and Belenios Sevdenur Baloglu, Sergiu Bursuc, Sjouke Mauw, Jun Pang Election Verifiability: Cryptographic Definitions and an Analysis of Helios, Helios-C, and JCJ Ben Smyth, Steven Frink, Michael R. Clarkson","title":"Academic papers"},{"location":"ref_literature/#academic-papers-assessing-helios","text":"","title":"Academic papers assessing Helios"},{"location":"ref_literature/#2008","text":"Helios: Web-based Open-Audit Voting Ben Adida Presentation of an early version of helios to the 17 th USENIX Security Symposium, 2008","title":"2008"},{"location":"ref_literature/#2009","text":"Electing a University President using Open-Audit Voting: Analysis of real-world use of Helios Ben Adida, Olivier Pereira, Olivier de Marneffe, Jean-Jacques Quisquater Presentation to Electronic Voting Technology Workshop/Workshop on Trustworthy Elections, 2009 Usability Study of the Open Audit Voting System Helios Janna-Lynn Weber, Urs Hengartner","title":"2009"},{"location":"ref_literature/#2010","text":"Exploiting the Client Vulnerabilities in Internet E-voting Systems: Hacking Helios 2.0 as an Example Saghar Estehghari, Yvo Desmedt The Helios e-Voting Demo for the IACR Stuart Haber, Josh Benaloh, Shai Halevi","title":"2010"},{"location":"ref_literature/#2011","text":"Running mixnet-based elections with Helios Philippe Bulens, Damien Giry, Olivier Pereira Presentation to Electronic Voting Technology Workshop/Workshop on Trustworthy Elections, 2011 User study of the improved Helios voting system interfaces Fatih Karayumak, Michaela Kauer, M. Maina Olembo, Tobias Volk, Melanie Volkamer Adapting Helios for provable ballot privacy David Bernhard, V\u00e9ronique Cortier, Olivier Pereira, Ben Smyth, Bogdan Warinschi Usability Analysis of Helios - An Open Source Verifiable Remote Electronic Voting System Fatih Karayumak, Maina M. Olembo, Michaela Kauer and Melanie Volkamer","title":"2011"},{"location":"ref_literature/#2013","text":"A generic construction for voting correctness at minimum cost - Application to Helios V\u00e9ronique Cortier, David Galindo, St\u00e9phane Glondu, Malika Izabach\u00e8ne Attacking and fixing Helios: An analysis of ballot secrecy V\u00e9ronique Cortier and Ben Smyth Distributed ElGamal \u00e0 la Pedersen - Application to Helios V\u00e9ronique Cortier, David Galindo, St\u00e9phane Glondu, Malika Izabache\u0300ne","title":"2013"},{"location":"ref_literature/#2014","text":"Usability of Voter Verifiable, End-to-end Voting Systems: Baseline Data for Helios, Pre\u0302t a\u0300 Voter, and Scantegrity II Claudia Z. Acemyan, Philip Kortum, Michael D. Byrne, Dan S. Wallach Helios Verification: To Alleviate, or to Nominate: Is That The Question, Or Shall We Have Both? Stephan Neumann, M. Maina Olembo, Karen Renaud, and Melanie Volkamer A Security Analysis of the Helios Voting Protocol and Application to the Norwegian County Election Kristine Salamonsen (Masters thesis)","title":"2014"},{"location":"ref_literature/#2015","text":"Extending Helios Towards Private Eligibility Verifiability Oksana Kulyk, Vanessa Teague, and Melanie Volkamer E-Voting and Identity: 5 th International Conference, VoteID 2015 Election Verifiability for Helios under Weaker Trust Assumptions Ve\u0301ronique Cortier, David Galindo, Ste\u0301phane Glondu and Malika Izabache\u0300ne","title":"2015"},{"location":"ref_literature/#2016","text":"Internet voting with Helios Olivier Pereira Chapter in: Feng Hao and Peter Y. A. Ryan (Eds.), Real-World Electronic Voting: Design, Analysis and Deployment , 2016 The Cloudier Side of Cryptographic End-to-end Verifiable Voting: A Security Analysis of Helios Nicholas Chang-Fong, Aleksander Essex Proceedings of the 32 nd Annual Conference on Computer Security Applications, 2016 Implementation-level Analysis of the JavaScript Helios Voting Client Michael Backes, Christian Hammer, David Pfaff, Malte Skoruppa Proceedings of the 31 st Annual ACM Symposium on Applied Computing, 2016 How not to Prove Yourself: Pitfalls of the Fiat-Shamir Heuristic and Applications to Helios David Bernhard, Olivier Pereira, and Bogdan Warinschi Adapting Helios for provable ballot privacy David Bernhard, V\u00e9ronique Cortier, Olivier Pereira, Ben Smyth, Bogdan Warinschi Introducing Proxy Voting to Helios Oksana Kulyk, Karola Marky, Stephan Neumann, Melanie Volkamer Apollo \u2013 End-to-end Verifiable Internet Voting with Recovery from Vote Manipulation Dawid Gawel, Maciej Kosarzecki, Poorvi L. Vora, Hua Wu, and Filip Zag\u00f3rski Cryptographic Voting \u2014 A Gentle Introduction David Bernhard, Bogdan Warinschi","title":"2016"},{"location":"ref_literature/#2017","text":"Machine-Checked Proofs of Privacy for Electronic Voting Protocols V\u00e9ronique Cortier, Constantin C\u0103t\u0103lin Dr\u0103gan, Fran\u00e7ois Dupressoir, Benedikt Schmidt, Pierre-Yves Strub, Bogdan Warinschi Security Proofs for Participation Privacy, Receipt-Freeness, Ballot Privacy for the Helios Voting Scheme David Bernhard, Oksana Kulyk, Melanie Volkamer","title":"2017"},{"location":"ref_literature/#2018","text":"E-voting system evaluation based on the Council of Europe recommendations: Helios Voting Luis Panizo, Mila Gasco\u0301, David Y. Marcos del Blanco, Jose\u0301 A. Hermida, Jordi Barrat and He\u0301ctor Ala\u0301iz IEEE Transactions on Emerging Topics in Computing, 2018 Comparative Usability Evaluation of Cast-as-Intended Verification Approaches in Internet Voting Karola Marky, Oksana Kulyk, Melanie Volkamer Ballot secrecy: Security definition, sufficient conditions, and analysis of Helios Ben Smyth Exploiting re-voting in the Helios election system Maxime Meyera, Ben Smyth Verifiability of Helios Mixnet Ben Smyth A foundation for secret, verifiable elections Ben Smyth","title":"2018"},{"location":"ref_literature/#2019","text":"A protocolized, comparative study of Helios Voting and Scytl/iVote David Y Marcos del Blanco and Mila Gasco\u0301 Sixth International Conference on eDemocracy & eGovernment (ICEDEG), 2019 A Framework for I-Voting based on Helios and Public-Key Certificates Noor Hamad Abid, Sufyan T. Faraj Al-Janabi A simple alternative to Benaloh challenge for the cast-as-intended property in Helios/Belenios Ve\u0301ronique Cortier, Jannik Dreier, Pierrick Gaudry, Mathieu Turuani","title":"2019"},{"location":"ref_literature/#2020","text":"Fifty Shades of Ballot Privacy: Privacy against a Malicious Board V\u00e9ronique Cortier, Joseph Lallemand, Bogdan Warinschi The Secure I-Voting System Helios++ Noor Hamad Abid, Sufyan T. Faraj Al-Janabi Verifiable Public Credentials for Stronger End-to-End Verifiability Sevdenur Baloglu","title":"2020"},{"location":"ref_literature/#2021","text":"Helios: Attacks and Formal Models for Verifiability Panagiotis Grontas Election Verifiability Revisited: Automated Security Proofs and Attacks on Helios and Belenios Sevdenur Baloglu, Sergiu Bursuc, Sjouke Mauw, Jun Pang Election Verifiability: Cryptographic Definitions and an Analysis of Helios, Helios-C, and JCJ Ben Smyth, Steven Frink, Michael R. Clarkson","title":"2021"},{"location":"ref_models/","text":"Models \"A model class represents a database table, and an instance of that class represents a particular record in the database table.\" Django docs helios Election class Field Type Default Comment uuid Char datatype Char legacy/Election short_name Char unique=True Set by admin name Char Set by admin election_type Char choices= [('election', 'Election'), ('referendum', 'Referendum')], default=election private_p Boolean False description Text public_key LDObject null=True private_key LDObject null=True questions LDObject null=True eligibility LDObject null=True openreg Boolean False featured_p Boolean False use_voter_aliases Boolean False use_advanced_audit_features Boolean True randomize_answer_order Boolean False cast_url Char created_at DateTime auto_now_add=True modified_at DateTime auto_now_add=True frozen_at DateTime None, null=True archived_at DateTime None, null=True registration_starts_at DateTime None, null=True voting_starts_at DateTime None, null=True voting_ends_at DateTime None, null=True complaint_period_ends_at DateTime None, null=True tallying_starts_at DateTime None, null=True voting_started_at DateTime None, null=True voting_extended_until DateTime None, null=True voting_ended_at DateTime None, null=True tallying_started_at DateTime None, null=True tallying_finished_at DateTime None, null=True tallies_combined_at DateTime None, null=True result_released_at DateTime None, null=True voters_hash Char null=True encrypted_tally LDObject null=True result LDObject null=True result_proof jsonfield.JSON null=True help_email Email null=True election_info_url Char null=True voter_webid Char null=True VoterFile class Field Type Default Comment voter_file File null=True This is a comment voter_file_content Text null=True uploaded_at DateTime auto_now_add=True processing_started_at DateTime null=True processing_finished_at DateTime null=True num_voters Integer null=True election ForeignKey Voter class Field Type Default Comment uuid Char This is a comment voter_login_id Char null=True voter_password Char null=True voter_name Char null=True voter_email Char null=True alias Char null=True vote LDObject null=True vote_hash Char null=True cast_at DateTime null=True election ForeignKey user ForeignKey ElectionLog class Field Type Default Comments log Char This is a comment at DateTime auto_now_add=True election ForeignKey CastVote class Field Type Default Comments vote LDObject This is a comment vote_hash Char vote_tinyhash Char null=True unique=True cast_at DateTime auto_now_add=True quarantined_p Boolean False released_from_quarantine_at DateTime null=True verified_at DateTime null=True invalidated_at DateTime null=True cast_ip GenericIPAddress null=True voter ForeignKey AuditedBallot class Field Type Default Comments raw_vote Text This is a comment vote_hash Char added_at DateTime auto_now_add=True election ForeignKey Trustee class Field Type Default Comments uuid Char This is a comment name Char email Email secret Char public_key LDObject null=True public_key_hash Char secret_key LDObject null=True pok LDObject null=True decryption_factors LDObject null=True decryption_proofs LDObject null=True election ForeignKey helios_auth User class Field Type Default Comments user_type This is a comment user_id name null=True info jsonfield.JSONField token jsonfield.JSONField null=True admin_p Boolean False","title":"Models"},{"location":"ref_models/#models","text":"\"A model class represents a database table, and an instance of that class represents a particular record in the database table.\" Django docs","title":"Models"},{"location":"ref_models/#helios","text":"","title":"helios"},{"location":"ref_models/#election-class","text":"Field Type Default Comment uuid Char datatype Char legacy/Election short_name Char unique=True Set by admin name Char Set by admin election_type Char choices= [('election', 'Election'), ('referendum', 'Referendum')], default=election private_p Boolean False description Text public_key LDObject null=True private_key LDObject null=True questions LDObject null=True eligibility LDObject null=True openreg Boolean False featured_p Boolean False use_voter_aliases Boolean False use_advanced_audit_features Boolean True randomize_answer_order Boolean False cast_url Char created_at DateTime auto_now_add=True modified_at DateTime auto_now_add=True frozen_at DateTime None, null=True archived_at DateTime None, null=True registration_starts_at DateTime None, null=True voting_starts_at DateTime None, null=True voting_ends_at DateTime None, null=True complaint_period_ends_at DateTime None, null=True tallying_starts_at DateTime None, null=True voting_started_at DateTime None, null=True voting_extended_until DateTime None, null=True voting_ended_at DateTime None, null=True tallying_started_at DateTime None, null=True tallying_finished_at DateTime None, null=True tallies_combined_at DateTime None, null=True result_released_at DateTime None, null=True voters_hash Char null=True encrypted_tally LDObject null=True result LDObject null=True result_proof jsonfield.JSON null=True help_email Email null=True election_info_url Char null=True voter_webid Char null=True","title":"Election class"},{"location":"ref_models/#voterfile-class","text":"Field Type Default Comment voter_file File null=True This is a comment voter_file_content Text null=True uploaded_at DateTime auto_now_add=True processing_started_at DateTime null=True processing_finished_at DateTime null=True num_voters Integer null=True election ForeignKey","title":"VoterFile class"},{"location":"ref_models/#voter-class","text":"Field Type Default Comment uuid Char This is a comment voter_login_id Char null=True voter_password Char null=True voter_name Char null=True voter_email Char null=True alias Char null=True vote LDObject null=True vote_hash Char null=True cast_at DateTime null=True election ForeignKey user ForeignKey","title":"Voter class"},{"location":"ref_models/#electionlog-class","text":"Field Type Default Comments log Char This is a comment at DateTime auto_now_add=True election ForeignKey","title":"ElectionLog class"},{"location":"ref_models/#castvote-class","text":"Field Type Default Comments vote LDObject This is a comment vote_hash Char vote_tinyhash Char null=True unique=True cast_at DateTime auto_now_add=True quarantined_p Boolean False released_from_quarantine_at DateTime null=True verified_at DateTime null=True invalidated_at DateTime null=True cast_ip GenericIPAddress null=True voter ForeignKey","title":"CastVote class"},{"location":"ref_models/#auditedballot-class","text":"Field Type Default Comments raw_vote Text This is a comment vote_hash Char added_at DateTime auto_now_add=True election ForeignKey","title":"AuditedBallot class"},{"location":"ref_models/#trustee-class","text":"Field Type Default Comments uuid Char This is a comment name Char email Email secret Char public_key LDObject null=True public_key_hash Char secret_key LDObject null=True pok LDObject null=True decryption_factors LDObject null=True decryption_proofs LDObject null=True election ForeignKey","title":"Trustee class"},{"location":"ref_models/#helios_auth","text":"","title":"helios_auth"},{"location":"ref_models/#user-class","text":"Field Type Default Comments user_type This is a comment user_id name null=True info jsonfield.JSONField token jsonfield.JSONField null=True admin_p Boolean False","title":"User class"},{"location":"ref_terms/","text":"Terms audit ballot A ballot is a document setting out the choices the voter is entitled to make. It is presented to the voter in the voting booth. The voter makes their choices and saves the encrypted ballot to their pod. The application automatically sends a notification to the election admin for that election. ballot tracker election An election which is created by an election admin. Information relating to the election is stored on a database. The information includes: all voter webids encrypted ballots, once retrieved from pods election admin A person entitled to administer an election. An election admin may create an election. An election admin who creates an election: A person is entitled to administer an election if .... fingerprint user The currently logged in user who may be an election admin and / or a voter. Or: the currently logged in user who will be a voter and may be an election admin. voter A person who is registered to vote in the current election. voting booth","title":"Terms"},{"location":"ref_terms/#terms","text":"","title":"Terms"},{"location":"ref_terms/#audit","text":"","title":"audit"},{"location":"ref_terms/#ballot","text":"A ballot is a document setting out the choices the voter is entitled to make. It is presented to the voter in the voting booth. The voter makes their choices and saves the encrypted ballot to their pod. The application automatically sends a notification to the election admin for that election.","title":"ballot"},{"location":"ref_terms/#ballot-tracker","text":"","title":"ballot tracker"},{"location":"ref_terms/#election","text":"An election which is created by an election admin. Information relating to the election is stored on a database. The information includes: all voter webids encrypted ballots, once retrieved from pods","title":"election"},{"location":"ref_terms/#election-admin","text":"A person entitled to administer an election. An election admin may create an election. An election admin who creates an election: A person is entitled to administer an election if ....","title":"election admin"},{"location":"ref_terms/#fingerprint","text":"","title":"fingerprint"},{"location":"ref_terms/#user","text":"The currently logged in user who may be an election admin and / or a voter. Or: the currently logged in user who will be a voter and may be an election admin.","title":"user"},{"location":"ref_terms/#voter","text":"A person who is registered to vote in the current election.","title":"voter"},{"location":"ref_terms/#voting-booth","text":"","title":"voting booth"},{"location":"sec_helios/","text":"Helios cryptography The election administrator sets up the election and generates a public - private key pair. The election has a set of trustees, each having a share of the private key but no-one holding the full private key. The public key is published. To cast a vote, the user runs a browser script that inputs her vote and creates a ballot that is encrypted with the public key of the election. The ballot includes a ZKP (Zero Knowledge Proof) that the ballot represents an allowed vote. The user can audit the ballot to check if it really represents a vote for her chosen candidate; if she elects to do this, the script provides her with the random data used in the ballot creation. She can then independently verify that the ballot was correctly constructed, but the ballot is now invalid and she has to create another one. When the voter has decided to cast her ballot, the voter\u2019s browser submits it along with her pseudo-identity to the server. The server checks the ZKPs of the ballots, and publishes them on a bulletin board. Individual voters can check that their ballots appear on the bulletin board. Any observer can check that the ballots that appear on the bulletin board represent allowed votes, by checking the ZKPs. The server homomorphically combines the ballots, and publishes the encrypted tally. Anyone can check that this tally is done correctly. The server submits the encrypted tally to each of the trustees, and obtains their share of the decryption key for that particular ciphertext, together with a proof that the key share is well-formed. The server publishes these key shares along with the proofs. Anyone can check the proofs. The server decrypts the tally and publishes the result. Anyone can check this decryption. There is also a good explanation in Usability Analysis of Helios - An Open Source Verifiable Remote Electronic Voting System Helios documentation \u21a9 This description is taken from https://bensmyth.com/files/Smyth10-definition-verifiability.LNCS.pdf \u21a9","title":"Helios cryptography"},{"location":"sec_helios/#helios-cryptography","text":"The election administrator sets up the election and generates a public - private key pair. The election has a set of trustees, each having a share of the private key but no-one holding the full private key. The public key is published. To cast a vote, the user runs a browser script that inputs her vote and creates a ballot that is encrypted with the public key of the election. The ballot includes a ZKP (Zero Knowledge Proof) that the ballot represents an allowed vote. The user can audit the ballot to check if it really represents a vote for her chosen candidate; if she elects to do this, the script provides her with the random data used in the ballot creation. She can then independently verify that the ballot was correctly constructed, but the ballot is now invalid and she has to create another one. When the voter has decided to cast her ballot, the voter\u2019s browser submits it along with her pseudo-identity to the server. The server checks the ZKPs of the ballots, and publishes them on a bulletin board. Individual voters can check that their ballots appear on the bulletin board. Any observer can check that the ballots that appear on the bulletin board represent allowed votes, by checking the ZKPs. The server homomorphically combines the ballots, and publishes the encrypted tally. Anyone can check that this tally is done correctly. The server submits the encrypted tally to each of the trustees, and obtains their share of the decryption key for that particular ciphertext, together with a proof that the key share is well-formed. The server publishes these key shares along with the proofs. Anyone can check the proofs. The server decrypts the tally and publishes the result. Anyone can check this decryption. There is also a good explanation in Usability Analysis of Helios - An Open Source Verifiable Remote Electronic Voting System Helios documentation \u21a9 This description is taken from https://bensmyth.com/files/Smyth10-definition-verifiability.LNCS.pdf \u21a9","title":"Helios cryptography"},{"location":"todo/","text":"TODO Lorem ipsum dolor sit amet, consectetur adipiscing elit Nulla lobortis egestas semper Curabitur elit nibh, euismod et ullamcorper at, iaculis feugiat est Vestibulum convallis sit amet nisi a tincidunt In hac habitasse platea dictumst In scelerisque nibh non dolor mollis congue sed et metus Sed egestas felis quis elit dapibus, ac aliquet turpis mattis Praesent sed risus massa Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque Nulla vel eros venenatis, imperdiet enim id, faucibus nisi","title":"TODO"},{"location":"todo/#todo","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit Nulla lobortis egestas semper Curabitur elit nibh, euismod et ullamcorper at, iaculis feugiat est Vestibulum convallis sit amet nisi a tincidunt In hac habitasse platea dictumst In scelerisque nibh non dolor mollis congue sed et metus Sed egestas felis quis elit dapibus, ac aliquet turpis mattis Praesent sed risus massa Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque Nulla vel eros venenatis, imperdiet enim id, faucibus nisi","title":"TODO"},{"location":"use_admin_announces_results/","text":"Election admin announces results","title":"Election admin announces results"},{"location":"use_admin_announces_results/#election-admin-announces-results","text":"","title":"Election admin announces results"},{"location":"use_admin_tallies_ballots/","text":"Election admin tallies ballots [ To be completed]","title":"Admin tallies ballots"},{"location":"use_admin_tallies_ballots/#election-admin-tallies-ballots","text":"[ To be completed]","title":"Election admin tallies ballots"},{"location":"use_create_election/","text":"Election admin creates an election To create and administer an election, you will need to log in using Google, Facebook, Yahoo, or Twitter. Helios queries and retains only the basic information needed to authenticate you the next time around: your name, email address, and user ID. Helios will use this information to message you when your election requires attention. 1 As an election administrator, you have the power to designate who can vote, when the election starts, when the election stops, and when the results are released. Other than that, you have no power beyond what voters in your election have. This is by design. 1 On the home page for Helios, after logging in, click on create election . Create election Complete the fields on the form and press Next >> . Once the election is added it will be possible to come back and edit it up until you choose to freeze it. Field Comment Short name no spaces, will be part of the URL for your election, e.g. my-club-2010 Name the pretty name for your election, e.g. My Club 2010 Election Description appears on main page for this election / referendum Type election / referendum; ??? Use voter aliases If selected, voter identities will be replaced with aliases, e.g. \"V12\", in the ballot tracking center Randomize answer order enable this if you want the answers to questions to appear in random order for each voter Private? A private election is only visible to registered voters. Help email address An email address voters should contact if they need help. Voting starts at UTC date and time when voting begins Voting ends at UTC date and time when voting ends Pressing Next >> takes you to the main page for the election. Election main page There is a statement about whether this election is featured on the front page. In order to feature elections on the front page the user field admin_p in the helios_auth_user database table needs to be set to True. Connect to the database in a termimal and run the SQL query: UPDATE helios_auth_user SET admin_p = 't' WHERE user_id = [your_user_id]; From this page you can set up: the questions for voting on voters and ballots trustees Questions For each 'question' a voter may vote for one or more 'answers'. A question might be 'Which two candidates should be elected?' and the available answers might be similar to candidate-one, candidate-two, candidate-three, candidate-four. You can set how many answers may be chosen and whether the results should be expressed in absolute number of votes or relative numbers of votes (percentages). You can associate a link with each answer (for example a link to further information about a candidate). Voters & ballots You may select one of: anyone can vote, a voter simply needs to log on, eg using Google authentication only the listed voters can vote If you choose the second option, you need to upload a list of voters contained in a csv file. Trustees A trustee uses a private key to decrypt the result of the tally. Helios is automatically a trustee. It is not necessary to add further trustees, but if you do, it is important they retain their secret keys. All secret keys will be required to decrypt the result. Freeze ballot and open election Once you have set up the questions made your selection in the voters & ballots section you can then freeze the election and open it for voting. If you uploaded a list of voters, you can, in the Voters & ballots section, send an email to all voters giving each of them their Voter ID and password. https://heliosvoting.org/privacy \u21a9 \u21a9","title":"Admin creates an election"},{"location":"use_create_election/#election-admin-creates-an-election","text":"To create and administer an election, you will need to log in using Google, Facebook, Yahoo, or Twitter. Helios queries and retains only the basic information needed to authenticate you the next time around: your name, email address, and user ID. Helios will use this information to message you when your election requires attention. 1 As an election administrator, you have the power to designate who can vote, when the election starts, when the election stops, and when the results are released. Other than that, you have no power beyond what voters in your election have. This is by design. 1 On the home page for Helios, after logging in, click on create election .","title":"Election admin creates an election"},{"location":"use_create_election/#create-election","text":"Complete the fields on the form and press Next >> . Once the election is added it will be possible to come back and edit it up until you choose to freeze it. Field Comment Short name no spaces, will be part of the URL for your election, e.g. my-club-2010 Name the pretty name for your election, e.g. My Club 2010 Election Description appears on main page for this election / referendum Type election / referendum; ??? Use voter aliases If selected, voter identities will be replaced with aliases, e.g. \"V12\", in the ballot tracking center Randomize answer order enable this if you want the answers to questions to appear in random order for each voter Private? A private election is only visible to registered voters. Help email address An email address voters should contact if they need help. Voting starts at UTC date and time when voting begins Voting ends at UTC date and time when voting ends Pressing Next >> takes you to the main page for the election.","title":"Create election"},{"location":"use_create_election/#election-main-page","text":"There is a statement about whether this election is featured on the front page. In order to feature elections on the front page the user field admin_p in the helios_auth_user database table needs to be set to True. Connect to the database in a termimal and run the SQL query: UPDATE helios_auth_user SET admin_p = 't' WHERE user_id = [your_user_id]; From this page you can set up: the questions for voting on voters and ballots trustees","title":"Election main page"},{"location":"use_create_election/#questions","text":"For each 'question' a voter may vote for one or more 'answers'. A question might be 'Which two candidates should be elected?' and the available answers might be similar to candidate-one, candidate-two, candidate-three, candidate-four. You can set how many answers may be chosen and whether the results should be expressed in absolute number of votes or relative numbers of votes (percentages). You can associate a link with each answer (for example a link to further information about a candidate).","title":"Questions"},{"location":"use_create_election/#voters-ballots","text":"You may select one of: anyone can vote, a voter simply needs to log on, eg using Google authentication only the listed voters can vote If you choose the second option, you need to upload a list of voters contained in a csv file.","title":"Voters &amp; ballots"},{"location":"use_create_election/#trustees","text":"A trustee uses a private key to decrypt the result of the tally. Helios is automatically a trustee. It is not necessary to add further trustees, but if you do, it is important they retain their secret keys. All secret keys will be required to decrypt the result.","title":"Trustees"},{"location":"use_create_election/#freeze-ballot-and-open-election","text":"Once you have set up the questions made your selection in the voters & ballots section you can then freeze the election and open it for voting. If you uploaded a list of voters, you can, in the Voters & ballots section, send an email to all voters giving each of them their Voter ID and password. https://heliosvoting.org/privacy \u21a9 \u21a9","title":"Freeze ballot and open election"},{"location":"use_register_voter/","text":"Person registers as voter When an election admin creates an election there is a 'Voters & ballots' section where the admin can choose to: allow any member of the public to vote; or, upload a list of eligible voters If the election is open to any member of the public, the voter logs in using one of the Helios authentication options (Google, Facebook etc) prior to casting a vote. If eligibility is by way of being on a list of eligible voters - this list is uploaded by the election admin at the time of creating the election. The Helios application does not provide a facility for a person to register as an eligible voter.","title":"Voter registers"},{"location":"use_register_voter/#person-registers-as-voter","text":"When an election admin creates an election there is a 'Voters & ballots' section where the admin can choose to: allow any member of the public to vote; or, upload a list of eligible voters If the election is open to any member of the public, the voter logs in using one of the Helios authentication options (Google, Facebook etc) prior to casting a vote. If eligibility is by way of being on a list of eligible voters - this list is uploaded by the election admin at the time of creating the election. The Helios application does not provide a facility for a person to register as an eligible voter.","title":"Person registers as voter"},{"location":"use_voter_votes/","text":"Voter votes The ballot casting application is implemented as a single-page web application using JavaScript. In particular, all necessary data is preloaded into the browser\u2019s memory and the JavaScript code up- dates the rendered HTML user interface when any links or buttons are clicked. As a result, no Internet access is required from the time the data is loaded onto the web browser, until one is ready to cast their vote. Anyone using a modern web browser running JavaScript (e.g. Firefox 2 or later), is able to cast a vote. 1 Admin has uploaded a voter list First, an invitation email containing the URL of the election page, an election fingerprint, the Voter-ID and the assigned password is sent to the voter. 1 The voter clicks on the URL to open the \u2018Voting Booth\u2019 web-page which contains instructions on the voting procedure. After reading the instructions the voter presses the \u2018Start\u2019 button on this page to invoke a JavaScript session on their computer. The JavaScript code will lead the voter through the ballot casting procedure without a connection to the Internet. An empty ballot is first displayed. Upon making a selection, depending on the maximum number of candidates allowed, the voter gets a warning message pointing to the limit of the options. To continue the ballot casting process the voter clicks the \u2018Proceed\u2019 button and is forwarded to a page where all selected candidates are displayed. The voter can review their selection here, having then the chance to change this selection by clicking the link \u2018Update\u2019 or seal the ballot by pressing the button \u2018Confirm Choices and Encrypt Ballot\u2019. To continue the process, the voter can either submit or verify their encrypted vote by pressing the \u2018Proceed to Cast\u2019 button or the \u2018Audit\u2019 link respectively. Note that on this page, the smart ballot tracker is displayed along with two links to \u2018print\u2019 or \u2018email\u2019 the smart ballot tracker. The voter should use either of these options or record the smart ballot tracker for later verification. The voter may also copy and paste this information elsewhere. If the voter opts to verify, and clicks the \u2018audit\u2019 link, the JavaScript then displays a new page with the mathematical proofs of the encryption as well as instructions on how to verify the encrypted vote. The voter should copy the displayed information, click on the \u2018Ballot Verifier\u2019 link and paste the copied information into the \u2018Helios Single-Ballot Verifier\u2019 page which pops up. On clicking the \u2018Verify\u2019 button, they receive the results at the bottom of the page. As the \u2018Helios Single-Ballot Verifier\u2019 is an independent application with its own window, the voter can go back to the main ballot casting application at any time (e.g. by closing the verification application). In order to continue with the voting process, the voter clicks the \u2018back to voting\u2019 button. After that they will need to re-encrypt the ballot. The voter can then decide whether to cast the encrypted vote or to verify it again. If voter clicks the \u2018Proceed to Cast\u2019 button they are forwarded to the login page where the smart ballot tracker is displayed again. The voter enters the Voter-ID and the assigned password from the invitation email in order to proceed. On pressing the \u2018check credentials\u2019 button, the system confirms eligibility. If they are authenticated, the voter can in the next step finally cast the vote (by pressing the \u2018I am \u2014, cast this ballot\u2019 button). Alternatively they can click the \u2018cancel\u2019 button and cancel the election. A success message is displayed once the encrypted vote is successfully cast. The voter is redirected to the election information page by clicking the link \u2018return to election info\u2019. This page contains information on the election, verifying procedure and provides a link labeled \u2018Vote in this election\u2019 for the voter to start the election process afresh if they so choose. Finally, a confirmation email is sent to the voter. Ballot preparation and casting including individual verifiability are based on Benaloh\u2019s Simple Verifiable Voting Protocol, which is based on two aspects - separating ballot preparation/encryption and ballot casting as well as on Benaloh\u2019s challenge. The idea of separation means that the ballot can be viewed, selections can be made, the ballot can be encrypted and the encryption can be verified without having to authenticate oneself and, thus, without being an eligible voter. The voter only needs to be authenticated for the final ballot casting. An advantage of this approach is that everyone (including election observers) can verify the ballot preparation mechanism. In Benaloh\u2019s challenge, the system commits to the encrypted vote and then voters can decide whether they want to verify or cast the vote. The software cannot falsify information by encrypting the wrong candidate since it does not know whether the voter will either verify or cast the encrypted vote. Voters will notice during verification if the wrong candidate name is encrypted. In order to ensure that the software provides the same ciphertext for verifiability and ballot casting (instead of sending the properly encrypted vote to the system in case of verifiability and the ciphertext of a wrong candidate in case of ballot casting), it commits to its encryption by displaying a hash value of the ciphertext, which is the smart ballot tracker. Privacy requirements make it impossible to cast a verified vote. The verified encrypted vote therefore has to be re-encrypted. Correspondingly, a new hash value is computed and displayed. Thus, the voter cannot verify the encrypted vote they finally cast but must trust the system due to previous checks. Admin has set voting open to public If the admin has set up the election so that voting is open to any member of the public, a voter logs in using one of the Helios authentication options. The voting process is the same as for a voter who is on a list that is uploaded by an election admin. This explanation of the voter process is taken from Usability Analysis of Helios - An Open Source Verifiable Remote Electronic Voting System \u21a9 \u21a9","title":"Voter votes"},{"location":"use_voter_votes/#voter-votes","text":"The ballot casting application is implemented as a single-page web application using JavaScript. In particular, all necessary data is preloaded into the browser\u2019s memory and the JavaScript code up- dates the rendered HTML user interface when any links or buttons are clicked. As a result, no Internet access is required from the time the data is loaded onto the web browser, until one is ready to cast their vote. Anyone using a modern web browser running JavaScript (e.g. Firefox 2 or later), is able to cast a vote. 1 Admin has uploaded a voter list First, an invitation email containing the URL of the election page, an election fingerprint, the Voter-ID and the assigned password is sent to the voter. 1 The voter clicks on the URL to open the \u2018Voting Booth\u2019 web-page which contains instructions on the voting procedure. After reading the instructions the voter presses the \u2018Start\u2019 button on this page to invoke a JavaScript session on their computer. The JavaScript code will lead the voter through the ballot casting procedure without a connection to the Internet. An empty ballot is first displayed. Upon making a selection, depending on the maximum number of candidates allowed, the voter gets a warning message pointing to the limit of the options. To continue the ballot casting process the voter clicks the \u2018Proceed\u2019 button and is forwarded to a page where all selected candidates are displayed. The voter can review their selection here, having then the chance to change this selection by clicking the link \u2018Update\u2019 or seal the ballot by pressing the button \u2018Confirm Choices and Encrypt Ballot\u2019. To continue the process, the voter can either submit or verify their encrypted vote by pressing the \u2018Proceed to Cast\u2019 button or the \u2018Audit\u2019 link respectively. Note that on this page, the smart ballot tracker is displayed along with two links to \u2018print\u2019 or \u2018email\u2019 the smart ballot tracker. The voter should use either of these options or record the smart ballot tracker for later verification. The voter may also copy and paste this information elsewhere. If the voter opts to verify, and clicks the \u2018audit\u2019 link, the JavaScript then displays a new page with the mathematical proofs of the encryption as well as instructions on how to verify the encrypted vote. The voter should copy the displayed information, click on the \u2018Ballot Verifier\u2019 link and paste the copied information into the \u2018Helios Single-Ballot Verifier\u2019 page which pops up. On clicking the \u2018Verify\u2019 button, they receive the results at the bottom of the page. As the \u2018Helios Single-Ballot Verifier\u2019 is an independent application with its own window, the voter can go back to the main ballot casting application at any time (e.g. by closing the verification application). In order to continue with the voting process, the voter clicks the \u2018back to voting\u2019 button. After that they will need to re-encrypt the ballot. The voter can then decide whether to cast the encrypted vote or to verify it again. If voter clicks the \u2018Proceed to Cast\u2019 button they are forwarded to the login page where the smart ballot tracker is displayed again. The voter enters the Voter-ID and the assigned password from the invitation email in order to proceed. On pressing the \u2018check credentials\u2019 button, the system confirms eligibility. If they are authenticated, the voter can in the next step finally cast the vote (by pressing the \u2018I am \u2014, cast this ballot\u2019 button). Alternatively they can click the \u2018cancel\u2019 button and cancel the election. A success message is displayed once the encrypted vote is successfully cast. The voter is redirected to the election information page by clicking the link \u2018return to election info\u2019. This page contains information on the election, verifying procedure and provides a link labeled \u2018Vote in this election\u2019 for the voter to start the election process afresh if they so choose. Finally, a confirmation email is sent to the voter. Ballot preparation and casting including individual verifiability are based on Benaloh\u2019s Simple Verifiable Voting Protocol, which is based on two aspects - separating ballot preparation/encryption and ballot casting as well as on Benaloh\u2019s challenge. The idea of separation means that the ballot can be viewed, selections can be made, the ballot can be encrypted and the encryption can be verified without having to authenticate oneself and, thus, without being an eligible voter. The voter only needs to be authenticated for the final ballot casting. An advantage of this approach is that everyone (including election observers) can verify the ballot preparation mechanism. In Benaloh\u2019s challenge, the system commits to the encrypted vote and then voters can decide whether they want to verify or cast the vote. The software cannot falsify information by encrypting the wrong candidate since it does not know whether the voter will either verify or cast the encrypted vote. Voters will notice during verification if the wrong candidate name is encrypted. In order to ensure that the software provides the same ciphertext for verifiability and ballot casting (instead of sending the properly encrypted vote to the system in case of verifiability and the ciphertext of a wrong candidate in case of ballot casting), it commits to its encryption by displaying a hash value of the ciphertext, which is the smart ballot tracker. Privacy requirements make it impossible to cast a verified vote. The verified encrypted vote therefore has to be re-encrypted. Correspondingly, a new hash value is computed and displayed. Thus, the voter cannot verify the encrypted vote they finally cast but must trust the system due to previous checks. Admin has set voting open to public If the admin has set up the election so that voting is open to any member of the public, a voter logs in using one of the Helios authentication options. The voting process is the same as for a voter who is on a list that is uploaded by an election admin. This explanation of the voter process is taken from Usability Analysis of Helios - An Open Source Verifiable Remote Electronic Voting System \u21a9 \u21a9","title":"Voter votes"}]}